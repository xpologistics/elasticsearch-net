using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using Elasticsearch.Net;

//This file lays the base for all the descriptors based on the query string parameters in the spec for IElasticClient.
//This file is automatically generated from https://github.com/elastic/elasticsearch/tree/master/rest-api-spec

namespace Nest6
{
	public abstract partial class RequestDescriptorBase<TDescriptor, TParameters, TInterface>
	{
		///<summary>Pretty format the returned JSON response.</summary>
		public TDescriptor Pretty(bool? pretty = true) => Qs("pretty", pretty);
		///<summary>Return human readable values for statistics.</summary>
		public TDescriptor Human(bool? human = true) => Qs("human", human);
		///<summary>Include the stack trace of returned errors.</summary>
		public TDescriptor ErrorTrace(bool? errorTrace = true) => Qs("error_trace", errorTrace);
		///<summary>A comma-separated list of filters used to reduce the respone.<para>Use of response filtering can result in a response from Elasticsearch that cannot be correctly deserialized to the respective response type for the request. In such situations, use the low level client to issue the request and handle response deserialization</para></summary>
		public TDescriptor FilterPath(string[] filterPath) => Qs("filter_path", filterPath);
	}

	///<summary>descriptor for Bulk <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-bulk.html</pre></summary>
	public partial class BulkDescriptor  : RequestDescriptorBase<BulkDescriptor,BulkRequestParameters, IBulkRequest>, IBulkRequest
	{ 
		/// <summary>/_bulk</summary>
		public BulkDescriptor() : base(){}
		// values part of the url path
		IndexName IBulkRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IBulkRequest.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>Default index for items which don't provide one</summary>
		public BulkDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public BulkDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (IndexName)v));

		///<summary>Default document type for items which don't provide one</summary>
		public BulkDescriptor Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public BulkDescriptor Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (TypeName)v));

		// Request parameters

		///<summary>Sets the number of shard copies that must be active before proceeding with the bulk operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public BulkDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.</summary>
		public BulkDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public BulkDescriptor Routing(Routing routing) => Qs("routing", routing);
		///<summary>Explicit operation timeout</summary>
		public BulkDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Default comma-separated list of fields to return in the response for updates, can be overridden on each sub-request</summary>
		public BulkDescriptor Fields(Fields fields) => Qs("fields", fields);
		///<summary>Default comma-separated list of fields to return in the response for updates, can be overridden on each sub-request</summary>
		public BulkDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("fields", fields?.Select(e=>(Field)e));

		///<summary>Whether the _source should be included in the response.</summary>
		public BulkDescriptor SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>Default list of fields to exclude from the returned _source field, can be overridden on each sub-request</summary>
		public BulkDescriptor SourceExclude(Fields sourceExclude) => Qs("_source_excludes", sourceExclude);
		///<summary>Default list of fields to exclude from the returned _source field, can be overridden on each sub-request</summary>
		public BulkDescriptor SourceExclude<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("_source_excludes", fields?.Select(e=>(Field)e));

		///<summary>Default list of fields to extract and return from the _source field, can be overridden on each sub-request</summary>
		public BulkDescriptor SourceInclude(Fields sourceInclude) => Qs("_source_includes", sourceInclude);
		///<summary>Default list of fields to extract and return from the _source field, can be overridden on each sub-request</summary>
		public BulkDescriptor SourceInclude<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("_source_includes", fields?.Select(e=>(Field)e));

		///<summary>The pipeline id to preprocess incoming documents with</summary>
		public BulkDescriptor Pipeline(string pipeline) => Qs("pipeline", pipeline);
	}
	///<summary>descriptor for CatAliases <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-alias.html</pre></summary>
	public partial class CatAliasesDescriptor  : RequestDescriptorBase<CatAliasesDescriptor,CatAliasesRequestParameters, ICatAliasesRequest>, ICatAliasesRequest
	{ 
		/// <summary>/_cat/aliases</summary>
		public CatAliasesDescriptor() : base(){}
		// values part of the url path
		Names ICatAliasesRequest.Name => Self.RouteValues.Get<Names>("name");

		///<summary>A comma-separated list of alias names to return</summary>
		public CatAliasesDescriptor Name(Names name) => Assign(name, (a,v)=>a.RouteValues.Optional("name", v));

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatAliasesDescriptor Format(string format) => Qs("format", format);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatAliasesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatAliasesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatAliasesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatAliasesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatAliasesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatAliasesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatAllocation <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-allocation.html</pre></summary>
	public partial class CatAllocationDescriptor  : RequestDescriptorBase<CatAllocationDescriptor,CatAllocationRequestParameters, ICatAllocationRequest>, ICatAllocationRequest
	{ 
		/// <summary>/_cat/allocation</summary>
		public CatAllocationDescriptor() : base(){}
		// values part of the url path
		NodeIds ICatAllocationRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");

		///<summary>A comma-separated list of node IDs or names to limit the returned information</summary>
		public CatAllocationDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a,v)=>a.RouteValues.Optional("node_id", v));

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatAllocationDescriptor Format(string format) => Qs("format", format);
		///<summary>The unit in which to display byte values</summary>
		public CatAllocationDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatAllocationDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatAllocationDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatAllocationDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatAllocationDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatAllocationDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatAllocationDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatCount <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-count.html</pre></summary>
	public partial class CatCountDescriptor  : RequestDescriptorBase<CatCountDescriptor,CatCountRequestParameters, ICatCountRequest>, ICatCountRequest
	{ 
		/// <summary>/_cat/count</summary>
		public CatCountDescriptor() : base(){}
		// values part of the url path
		Indices ICatCountRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatCountDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CatCountDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CatCountDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatCountDescriptor Format(string format) => Qs("format", format);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatCountDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatCountDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatCountDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatCountDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatCountDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatCountDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatFielddata <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-fielddata.html</pre></summary>
	public partial class CatFielddataDescriptor  : RequestDescriptorBase<CatFielddataDescriptor,CatFielddataRequestParameters, ICatFielddataRequest>, ICatFielddataRequest
	{ 
		/// <summary>/_cat/fielddata</summary>
		public CatFielddataDescriptor() : base(){}
		// values part of the url path
		Fields ICatFielddataRequest.Fields => Self.RouteValues.Get<Fields>("fields");

		///<summary>A comma-separated list of fields to return the fielddata size</summary>
		public CatFielddataDescriptor Fields(Fields fields) => Assign(fields, (a,v)=>a.RouteValues.Optional("fields", v));

		///<summary>A comma-separated list of fields to return the fielddata size</summary>
		public CatFielddataDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) => Assign(fields, (a,v)=>a.RouteValues.Optional("fields", (Fields)v));

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatFielddataDescriptor Format(string format) => Qs("format", format);
		///<summary>The unit in which to display byte values</summary>
		public CatFielddataDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatFielddataDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatFielddataDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatFielddataDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatFielddataDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatFielddataDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatFielddataDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatHealth <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-health.html</pre></summary>
	public partial class CatHealthDescriptor  : RequestDescriptorBase<CatHealthDescriptor,CatHealthRequestParameters, ICatHealthRequest>, ICatHealthRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatHealthDescriptor Format(string format) => Qs("format", format);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatHealthDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatHealthDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatHealthDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatHealthDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatHealthDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Set to false to disable timestamping</summary>
		public CatHealthDescriptor IncludeTimestamp(bool? includeTimestamp = true) => Qs("ts", includeTimestamp);
		///<summary>Verbose mode. Display column headers</summary>
		public CatHealthDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatHelp <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat.html</pre></summary>
	public partial class CatHelpDescriptor  : RequestDescriptorBase<CatHelpDescriptor,CatHelpRequestParameters, ICatHelpRequest>, ICatHelpRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Return help information</summary>
		public CatHelpDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatHelpDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
	}
	///<summary>descriptor for CatIndices <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-indices.html</pre></summary>
	public partial class CatIndicesDescriptor  : RequestDescriptorBase<CatIndicesDescriptor,CatIndicesRequestParameters, ICatIndicesRequest>, ICatIndicesRequest
	{ 
		/// <summary>/_cat/indices</summary>
		public CatIndicesDescriptor() : base(){}
		// values part of the url path
		Indices ICatIndicesRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatIndicesDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CatIndicesDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CatIndicesDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatIndicesDescriptor Format(string format) => Qs("format", format);
		///<summary>The unit in which to display byte values</summary>
		public CatIndicesDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatIndicesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatIndicesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatIndicesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>A health status ("green", "yellow", or "red" to filter only indices matching the specified health status</summary>
		public CatIndicesDescriptor Health(Health? health) => Qs("health", health);
		///<summary>Return help information</summary>
		public CatIndicesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Set to true to return stats only for primary shards</summary>
		public CatIndicesDescriptor Pri(bool? pri = true) => Qs("pri", pri);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatIndicesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatIndicesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatMaster <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-master.html</pre></summary>
	public partial class CatMasterDescriptor  : RequestDescriptorBase<CatMasterDescriptor,CatMasterRequestParameters, ICatMasterRequest>, ICatMasterRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatMasterDescriptor Format(string format) => Qs("format", format);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatMasterDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatMasterDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatMasterDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatMasterDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatMasterDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatMasterDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatNodeattrs <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodeattrs.html</pre></summary>
	public partial class CatNodeAttributesDescriptor  : RequestDescriptorBase<CatNodeAttributesDescriptor,CatNodeAttributesRequestParameters, ICatNodeAttributesRequest>, ICatNodeAttributesRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatNodeAttributesDescriptor Format(string format) => Qs("format", format);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatNodeAttributesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatNodeAttributesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatNodeAttributesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatNodeAttributesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatNodeAttributesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatNodeAttributesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatNodes <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodes.html</pre></summary>
	public partial class CatNodesDescriptor  : RequestDescriptorBase<CatNodesDescriptor,CatNodesRequestParameters, ICatNodesRequest>, ICatNodesRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatNodesDescriptor Format(string format) => Qs("format", format);
		///<summary>Return the full node ID instead of the shortened version (default: false)</summary>
		public CatNodesDescriptor FullId(bool? fullId = true) => Qs("full_id", fullId);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatNodesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatNodesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatNodesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatNodesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatNodesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatNodesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatPendingTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-pending-tasks.html</pre></summary>
	public partial class CatPendingTasksDescriptor  : RequestDescriptorBase<CatPendingTasksDescriptor,CatPendingTasksRequestParameters, ICatPendingTasksRequest>, ICatPendingTasksRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatPendingTasksDescriptor Format(string format) => Qs("format", format);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatPendingTasksDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatPendingTasksDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatPendingTasksDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatPendingTasksDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatPendingTasksDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatPendingTasksDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatPlugins <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-plugins.html</pre></summary>
	public partial class CatPluginsDescriptor  : RequestDescriptorBase<CatPluginsDescriptor,CatPluginsRequestParameters, ICatPluginsRequest>, ICatPluginsRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatPluginsDescriptor Format(string format) => Qs("format", format);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatPluginsDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatPluginsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatPluginsDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatPluginsDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatPluginsDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatPluginsDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatRecovery <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-recovery.html</pre></summary>
	public partial class CatRecoveryDescriptor  : RequestDescriptorBase<CatRecoveryDescriptor,CatRecoveryRequestParameters, ICatRecoveryRequest>, ICatRecoveryRequest
	{ 
		/// <summary>/_cat/recovery</summary>
		public CatRecoveryDescriptor() : base(){}
		// values part of the url path
		Indices ICatRecoveryRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatRecoveryDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CatRecoveryDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CatRecoveryDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatRecoveryDescriptor Format(string format) => Qs("format", format);
		///<summary>The unit in which to display byte values</summary>
		public CatRecoveryDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatRecoveryDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatRecoveryDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatRecoveryDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatRecoveryDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatRecoveryDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatRepositories <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-repositories.html</pre></summary>
	public partial class CatRepositoriesDescriptor  : RequestDescriptorBase<CatRepositoriesDescriptor,CatRepositoriesRequestParameters, ICatRepositoriesRequest>, ICatRepositoriesRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatRepositoriesDescriptor Format(string format) => Qs("format", format);
		///<summary>Return local information, do not retrieve the state from master node</summary>
		public CatRepositoriesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatRepositoriesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatRepositoriesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatRepositoriesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatRepositoriesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatRepositoriesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatSegments <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-segments.html</pre></summary>
	public partial class CatSegmentsDescriptor  : RequestDescriptorBase<CatSegmentsDescriptor,CatSegmentsRequestParameters, ICatSegmentsRequest>, ICatSegmentsRequest
	{ 
		/// <summary>/_cat/segments</summary>
		public CatSegmentsDescriptor() : base(){}
		// values part of the url path
		Indices ICatSegmentsRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatSegmentsDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CatSegmentsDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CatSegmentsDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatSegmentsDescriptor Format(string format) => Qs("format", format);
		///<summary>The unit in which to display byte values</summary>
		public CatSegmentsDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>Comma-separated list of column names to display</summary>
		public CatSegmentsDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatSegmentsDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatSegmentsDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatSegmentsDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatShards <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-shards.html</pre></summary>
	public partial class CatShardsDescriptor  : RequestDescriptorBase<CatShardsDescriptor,CatShardsRequestParameters, ICatShardsRequest>, ICatShardsRequest
	{ 
		/// <summary>/_cat/shards</summary>
		public CatShardsDescriptor() : base(){}
		// values part of the url path
		Indices ICatShardsRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatShardsDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CatShardsDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CatShardsDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatShardsDescriptor Format(string format) => Qs("format", format);
		///<summary>The unit in which to display byte values</summary>
		public CatShardsDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatShardsDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatShardsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatShardsDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatShardsDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatShardsDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatShardsDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatSnapshots <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-snapshots.html</pre></summary>
	public partial class CatSnapshotsDescriptor  : RequestDescriptorBase<CatSnapshotsDescriptor,CatSnapshotsRequestParameters, ICatSnapshotsRequest>, ICatSnapshotsRequest
	{ 
		/// <summary>/_cat/snapshots</summary>
		public CatSnapshotsDescriptor() : base(){}
		// values part of the url path
		Names ICatSnapshotsRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");

		///<summary>Name of repository from which to fetch the snapshot information</summary>
		public CatSnapshotsDescriptor RepositoryName(Names repository) => Assign(repository, (a,v)=>a.RouteValues.Optional("repository", v));

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatSnapshotsDescriptor Format(string format) => Qs("format", format);
		///<summary>Set to true to ignore unavailable snapshots</summary>
		public CatSnapshotsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatSnapshotsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatSnapshotsDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatSnapshotsDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatSnapshotsDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatSnapshotsDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class CatTasksDescriptor  : RequestDescriptorBase<CatTasksDescriptor,CatTasksRequestParameters, ICatTasksRequest>, ICatTasksRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatTasksDescriptor Format(string format) => Qs("format", format);
		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public CatTasksDescriptor NodeId(params string[] nodeId) => Qs("node_id", nodeId);
		///<summary>A comma-separated list of actions that should be returned. Leave empty to return all.</summary>
		public CatTasksDescriptor Actions(params string[] actions) => Qs("actions", actions);
		///<summary>Return detailed task information (default: false)</summary>
		public CatTasksDescriptor Detailed(bool? detailed = true) => Qs("detailed", detailed);
		///<summary>Return tasks with specified parent task id. Set to -1 to return all.</summary>
		public CatTasksDescriptor ParentTask(long? parentTask) => Qs("parent_task", parentTask);
		///<summary>Comma-separated list of column names to display</summary>
		public CatTasksDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatTasksDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatTasksDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatTasksDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
		///<summary>Return tasks with the specified parent node</summary>
		[Obsolete("Scheduled to be removed in 7.0, Removed in 6.3.0 from the server see https://github.com/elastic/elasticsearch/pull/28841")]
		public CatTasksDescriptor ParentNode(string parentNode) => Qs("parent_node", parentNode);
	}
	///<summary>descriptor for CatTemplates <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-templates.html</pre></summary>
	public partial class CatTemplatesDescriptor  : RequestDescriptorBase<CatTemplatesDescriptor,CatTemplatesRequestParameters, ICatTemplatesRequest>, ICatTemplatesRequest
	{ 
		/// <summary>/_cat/templates</summary>
		public CatTemplatesDescriptor() : base(){}
		// values part of the url path
		Name ICatTemplatesRequest.Name => Self.RouteValues.Get<Name>("name");

		///<summary>A pattern that returned template names must match</summary>
		public CatTemplatesDescriptor Name(Name name) => Assign(name, (a,v)=>a.RouteValues.Optional("name", v));

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatTemplatesDescriptor Format(string format) => Qs("format", format);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatTemplatesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatTemplatesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatTemplatesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatTemplatesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatTemplatesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatTemplatesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for CatThreadPool <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-thread-pool.html</pre></summary>
	public partial class CatThreadPoolDescriptor  : RequestDescriptorBase<CatThreadPoolDescriptor,CatThreadPoolRequestParameters, ICatThreadPoolRequest>, ICatThreadPoolRequest
	{ 
		/// <summary>/_cat/thread_pool</summary>
		public CatThreadPoolDescriptor() : base(){}
		// values part of the url path
		Names ICatThreadPoolRequest.ThreadPoolPatterns => Self.RouteValues.Get<Names>("thread_pool_patterns");

		///<summary>A comma-separated list of regular-expressions to filter the thread pools in the output</summary>
		public CatThreadPoolDescriptor ThreadPoolPatterns(Names threadPoolPatterns) => Assign(threadPoolPatterns, (a,v)=>a.RouteValues.Optional("thread_pool_patterns", v));

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatThreadPoolDescriptor Format(string format) => Qs("format", format);
		///<summary>The multiplier in which to display values</summary>
		public CatThreadPoolDescriptor Size(Size? size) => Qs("size", size);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatThreadPoolDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatThreadPoolDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names to display</summary>
		public CatThreadPoolDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatThreadPoolDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatThreadPoolDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatThreadPoolDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}
	///<summary>descriptor for ClearScroll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html</pre></summary>
	public partial class ClearScrollDescriptor  : RequestDescriptorBase<ClearScrollDescriptor,ClearScrollRequestParameters, IClearScrollRequest>, IClearScrollRequest
	{ 
		/// <summary>/_search/scroll</summary>
		public ClearScrollDescriptor() : base(){}
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for ClusterAllocationExplain <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-allocation-explain.html</pre></summary>
	public partial class ClusterAllocationExplainDescriptor  : RequestDescriptorBase<ClusterAllocationExplainDescriptor,ClusterAllocationExplainRequestParameters, IClusterAllocationExplainRequest>, IClusterAllocationExplainRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Return 'YES' decisions in explanation (default: false)</summary>
		public ClusterAllocationExplainDescriptor IncludeYesDecisions(bool? includeYesDecisions = true) => Qs("include_yes_decisions", includeYesDecisions);
		///<summary>Return information about disk usage and shard sizes (default: false)</summary>
		public ClusterAllocationExplainDescriptor IncludeDiskInfo(bool? includeDiskInfo = true) => Qs("include_disk_info", includeDiskInfo);
	}
	///<summary>descriptor for ClusterGetSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html</pre></summary>
	public partial class ClusterGetSettingsDescriptor  : RequestDescriptorBase<ClusterGetSettingsDescriptor,ClusterGetSettingsRequestParameters, IClusterGetSettingsRequest>, IClusterGetSettingsRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterGetSettingsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterGetSettingsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public ClusterGetSettingsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Whether to return all default clusters setting.</summary>
		public ClusterGetSettingsDescriptor IncludeDefaults(bool? includeDefaults = true) => Qs("include_defaults", includeDefaults);
	}
	///<summary>descriptor for ClusterHealth <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-health.html</pre></summary>
	public partial class ClusterHealthDescriptor  : RequestDescriptorBase<ClusterHealthDescriptor,ClusterHealthRequestParameters, IClusterHealthRequest>, IClusterHealthRequest
	{ 
		/// <summary>/_cluster/health</summary>
		public ClusterHealthDescriptor() : base(){}
		// values part of the url path
		Indices IClusterHealthRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>Limit the information returned to a specific index</summary>
		public ClusterHealthDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ClusterHealthDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public ClusterHealthDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Specify the level of detail for returned information</summary>
		public ClusterHealthDescriptor Level(Level? level) => Qs("level", level);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterHealthDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterHealthDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public ClusterHealthDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Wait until the specified number of shards is active</summary>
		public ClusterHealthDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>Wait until the specified number of nodes is available</summary>
		public ClusterHealthDescriptor WaitForNodes(string waitForNodes) => Qs("wait_for_nodes", waitForNodes);
		///<summary>Wait until all currently queued events with the given priority are processed</summary>
		public ClusterHealthDescriptor WaitForEvents(WaitForEvents? waitForEvents) => Qs("wait_for_events", waitForEvents);
		///<summary>Whether to wait until there are no relocating shards in the cluster</summary>
		public ClusterHealthDescriptor WaitForNoRelocatingShards(bool? waitForNoRelocatingShards = true) => Qs("wait_for_no_relocating_shards", waitForNoRelocatingShards);
		///<summary>Whether to wait until there are no initializing shards in the cluster</summary>
		public ClusterHealthDescriptor WaitForNoInitializingShards(bool? waitForNoInitializingShards = true) => Qs("wait_for_no_initializing_shards", waitForNoInitializingShards);
		///<summary>Wait until cluster is in a specific state</summary>
		public ClusterHealthDescriptor WaitForStatus(WaitForStatus? waitForStatus) => Qs("wait_for_status", waitForStatus);
	}
	///<summary>descriptor for ClusterPendingTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-pending.html</pre></summary>
	public partial class ClusterPendingTasksDescriptor  : RequestDescriptorBase<ClusterPendingTasksDescriptor,ClusterPendingTasksRequestParameters, IClusterPendingTasksRequest>, IClusterPendingTasksRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterPendingTasksDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Specify timeout for connection to master</summary>
		public ClusterPendingTasksDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for ClusterPutSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html</pre></summary>
	public partial class ClusterPutSettingsDescriptor  : RequestDescriptorBase<ClusterPutSettingsDescriptor,ClusterPutSettingsRequestParameters, IClusterPutSettingsRequest>, IClusterPutSettingsRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterPutSettingsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterPutSettingsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public ClusterPutSettingsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for ClusterRemoteInfo <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-remote-info.html</pre></summary>
	public partial class RemoteInfoDescriptor  : RequestDescriptorBase<RemoteInfoDescriptor,RemoteInfoRequestParameters, IRemoteInfoRequest>, IRemoteInfoRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for ClusterReroute <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-reroute.html</pre></summary>
	public partial class ClusterRerouteDescriptor  : RequestDescriptorBase<ClusterRerouteDescriptor,ClusterRerouteRequestParameters, IClusterRerouteRequest>, IClusterRerouteRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Simulate the operation only and return the resulting state</summary>
		public ClusterRerouteDescriptor DryRun(bool? dryRun = true) => Qs("dry_run", dryRun);
		///<summary>Return an explanation of why the commands can or cannot be executed</summary>
		public ClusterRerouteDescriptor Explain(bool? explain = true) => Qs("explain", explain);
		///<summary>Retries allocation of shards that are blocked due to too many subsequent allocation failures</summary>
		public ClusterRerouteDescriptor RetryFailed(bool? retryFailed = true) => Qs("retry_failed", retryFailed);
		///<summary>Limit the information returned to the specified metrics. Defaults to all but metadata</summary>
		public ClusterRerouteDescriptor Metric(params string[] metric) => Qs("metric", metric);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterRerouteDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public ClusterRerouteDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for ClusterState <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-state.html</pre></summary>
	public partial class ClusterStateDescriptor  : RequestDescriptorBase<ClusterStateDescriptor,ClusterStateRequestParameters, IClusterStateRequest>, IClusterStateRequest
	{ 
		/// <summary>/_cluster/state</summary>
		public ClusterStateDescriptor() : base(){}
		// values part of the url path
		Indices IClusterStateRequest.Index => Self.RouteValues.Get<Indices>("index");
		Metrics IClusterStateRequest.Metric => Self.RouteValues.Get<Metrics>("metric");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public ClusterStateDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ClusterStateDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public ClusterStateDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>Limit the information returned to the specified metrics</summary>
		public ClusterStateDescriptor Metric(ClusterStateMetric metric) => Assign(metric, (a,v)=>a.RouteValues.Optional("metric", (Metrics)v));

		// Request parameters

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterStateDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Specify timeout for connection to master</summary>
		public ClusterStateDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterStateDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Wait for the metadata version to be equal or greater than the specified metadata version</summary>
		public ClusterStateDescriptor WaitForMetadataVersion(long? waitForMetadataVersion) => Qs("wait_for_metadata_version", waitForMetadataVersion);
		///<summary>The maximum time to wait for wait_for_metadata_version before timing out</summary>
		public ClusterStateDescriptor WaitForTimeout(Time waitForTimeout) => Qs("wait_for_timeout", waitForTimeout);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ClusterStateDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ClusterStateDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ClusterStateDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	}
	///<summary>descriptor for ClusterStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-stats.html</pre></summary>
	public partial class ClusterStatsDescriptor  : RequestDescriptorBase<ClusterStatsDescriptor,ClusterStatsRequestParameters, IClusterStatsRequest>, IClusterStatsRequest
	{ 
		/// <summary>/_cluster/stats</summary>
		public ClusterStatsDescriptor() : base(){}
		// values part of the url path
		NodeIds IClusterStatsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");

		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public ClusterStatsDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a,v)=>a.RouteValues.Optional("node_id", v));

		// Request parameters

		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterStatsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Explicit operation timeout</summary>
		public ClusterStatsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for Count <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html</pre></summary>
	public partial class CountDescriptor<T>  : RequestDescriptorBase<CountDescriptor<T>,CountRequestParameters, ICountRequest>, ICountRequest
	{ 
		/// <summary>/_count</summary>
		public CountDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		// values part of the url path
		Indices ICountRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ICountRequest.Type => Self.RouteValues.Get<Types>("type");

		///<summary>A comma-separated list of indices to restrict the results</summary>
		public CountDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CountDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CountDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of types to restrict the results</summary>
		public CountDescriptor<T> Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public CountDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public CountDescriptor<T> AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public CountDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether specified concrete, expanded or aliased indices should be ignored when throttled</summary>
		public CountDescriptor<T> IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public CountDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public CountDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Include only documents with a specific `_score` value in the result</summary>
		public CountDescriptor<T> MinScore(double? minScore) => Qs("min_score", minScore);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public CountDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public CountDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Query in the Lucene query string syntax</summary>
		public CountDescriptor<T> QueryOnQueryString(string queryOnQueryString) => Qs("q", queryOnQueryString);
		///<summary>The analyzer to use for the query string</summary>
		public CountDescriptor<T> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public CountDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public CountDescriptor<T> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public CountDescriptor<T> Df(string df) => Qs("df", df);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public CountDescriptor<T> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>The maximum count for each shard, upon reaching which the query execution will terminate early</summary>
		public CountDescriptor<T> TerminateAfter(long? terminateAfter) => Qs("terminate_after", terminateAfter);
	}
	///<summary>descriptor for Create <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html</pre></summary>
	public partial class CreateDescriptor<TDocument>  : RequestDescriptorBase<CreateDescriptor<TDocument>,CreateRequestParameters, ICreateRequest<TDocument>>, ICreateRequest<TDocument>
	{ 
		/// <summary>/{index}/{type}/{id}/_create</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="type"> this parameter is required</param>
		///<param name="id"> this parameter is required</param>
		public CreateDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id))
		=> Q("routing", new Routing(() => AutoRouteDocument()));
		/// <summary>/{index}/{type}/{id}/_create</summary>
		///<param name="document"> describes an elasticsearch document of type <typeparamref name="TDocument"/> from which the index, type and id can be inferred</param>
		public CreateDescriptor(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id))
		{ this.DocumentFromPath(document.Document); Q("routing", new Routing(() => AutoRouteDocument() ?? document.Document));}
		partial void DocumentFromPath(TDocument document);
		// values part of the url path
		Id ICreateRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
		IndexName ICreateRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName ICreateRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>The name of the index</summary>
		public CreateDescriptor<TDocument> Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CreateDescriptor<TDocument> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		///<summary>The type of the document</summary>
		public CreateDescriptor<TDocument> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Required("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public CreateDescriptor<TDocument> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("type", (TypeName)v));

		// Request parameters

		///<summary>Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public CreateDescriptor<TDocument> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>ID of the parent document</summary>
		[Obsolete("Scheduled to be removed in 7.0, the parent parameter has been deprecated from elasticsearch, please use routing instead directly.")]
		public CreateDescriptor<TDocument> Parent(string parent) => Qs("parent", parent);
		///<summary>If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.</summary>
		public CreateDescriptor<TDocument> Refresh(Refresh? refresh) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public CreateDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Explicit operation timeout</summary>
		public CreateDescriptor<TDocument> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Explicit version number for concurrency control</summary>
		public CreateDescriptor<TDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public CreateDescriptor<TDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
		///<summary>The pipeline id to preprocess incoming documents with</summary>
		public CreateDescriptor<TDocument> Pipeline(string pipeline) => Qs("pipeline", pipeline);
	}
	///<summary>descriptor for Delete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete.html</pre></summary>
	public partial class DeleteDescriptor<T>  : RequestDescriptorBase<DeleteDescriptor<T>,DeleteRequestParameters, IDeleteRequest>, IDeleteRequest
	{ 
		/// <summary>/{index}/{type}/{id}</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="type"> this parameter is required</param>
		///<param name="id"> this parameter is required</param>
		public DeleteDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id))
		=> Q("routing", new Routing(() => AutoRouteDocument()));
		/// <summary>/{index}/{type}/{id}</summary>
		///<param name="document"> describes an elasticsearch document of type <typeparamref name="T"/> from which the index, type and id can be inferred</param>
		public DeleteDescriptor(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id))
		{ this.DocumentFromPath(document.Document); Q("routing", new Routing(() => AutoRouteDocument() ?? document.Document));}
		partial void DocumentFromPath(T document);
		// values part of the url path
		Id IDeleteRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IDeleteRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IDeleteRequest.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>The name of the index</summary>
		public DeleteDescriptor<T> Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DeleteDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		///<summary>The type of the document</summary>
		public DeleteDescriptor<T> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Required("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public DeleteDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("type", (TypeName)v));

		// Request parameters

		///<summary>Sets the number of shard copies that must be active before proceeding with the delete operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public DeleteDescriptor<T> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>ID of parent document</summary>
		[Obsolete("Scheduled to be removed in 7.0, the parent parameter has been deprecated from elasticsearch, please use routing instead directly.")]
		public DeleteDescriptor<T> Parent(string parent) => Qs("parent", parent);
		///<summary>If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.</summary>
		public DeleteDescriptor<T> Refresh(Refresh? refresh) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public DeleteDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Explicit operation timeout</summary>
		public DeleteDescriptor<T> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>only perform the delete operation if the last operation that has changed the document has the specified sequence number</summary>
		public DeleteDescriptor<T> IfSeqNo(long? ifSeqNo) => Qs("if_seq_no", ifSeqNo);
		///<summary>only perform the delete operation if the last operation that has changed the document has the specified primary term</summary>
		public DeleteDescriptor<T> IfPrimaryTerm(long? ifPrimaryTerm) => Qs("if_primary_term", ifPrimaryTerm);
		///<summary>Explicit version number for concurrency control</summary>
		public DeleteDescriptor<T> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public DeleteDescriptor<T> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}
	///<summary>descriptor for DeleteByQuery <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete-by-query.html</pre></summary>
	public partial class DeleteByQueryDescriptor<T>  : RequestDescriptorBase<DeleteByQueryDescriptor<T>,DeleteByQueryRequestParameters, IDeleteByQueryRequest>, IDeleteByQueryRequest
	{ 
		/// <summary>/{index}/_delete_by_query</summary>
		///<param name="index"> this parameter is required</param>
		public DeleteByQueryDescriptor(Indices index) : base(r=>r.Required("index", index).Required("type", (Types)typeof(T))){}
		// values part of the url path
		Indices IDeleteByQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IDeleteByQueryRequest.Type => Self.RouteValues.Get<Types>("type");

		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public DeleteByQueryDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DeleteByQueryDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public DeleteByQueryDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public DeleteByQueryDescriptor<T> Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public DeleteByQueryDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public DeleteByQueryDescriptor<T> AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>The analyzer to use for the query string</summary>
		public DeleteByQueryDescriptor<T> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public DeleteByQueryDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DeleteByQueryDescriptor<T> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public DeleteByQueryDescriptor<T> Df(string df) => Qs("df", df);
		///<summary>Starting offset (default: 0)</summary>
		public DeleteByQueryDescriptor<T> From(long? from) => Qs("from", from);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public DeleteByQueryDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public DeleteByQueryDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>What to do when the delete by query hits version conflicts?</summary>
		public DeleteByQueryDescriptor<T> Conflicts(Conflicts? conflicts) => Qs("conflicts", conflicts);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public DeleteByQueryDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public DeleteByQueryDescriptor<T> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public DeleteByQueryDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>Query in the Lucene query string syntax</summary>
		public DeleteByQueryDescriptor<T> QueryOnQueryString(string queryOnQueryString) => Qs("q", queryOnQueryString);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public DeleteByQueryDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public DeleteByQueryDescriptor<T> Scroll(Time scroll) => Qs("scroll", scroll);
		///<summary>Search operation type</summary>
		public DeleteByQueryDescriptor<T> SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Explicit timeout for each search request. Defaults to no timeout.</summary>
		public DeleteByQueryDescriptor<T> SearchTimeout(Time searchTimeout) => Qs("search_timeout", searchTimeout);
		///<summary>Number of hits to return (default: 10)</summary>
		public DeleteByQueryDescriptor<T> Size(long? size) => Qs("size", size);
		///<summary>A comma-separated list of <field>:<direction> pairs</summary>
		public DeleteByQueryDescriptor<T> Sort(params string[] sort) => Qs("sort", sort);
		///<summary>Whether the _source should be included in the response.</summary>
		public DeleteByQueryDescriptor<T> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public DeleteByQueryDescriptor<T> SourceExclude(Fields sourceExclude) => Qs("_source_excludes", sourceExclude);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public DeleteByQueryDescriptor<T> SourceExclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_excludes", fields?.Select(e=>(Field)e));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public DeleteByQueryDescriptor<T> SourceInclude(Fields sourceInclude) => Qs("_source_includes", sourceInclude);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public DeleteByQueryDescriptor<T> SourceInclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_includes", fields?.Select(e=>(Field)e));

		///<summary>The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.</summary>
		public DeleteByQueryDescriptor<T> TerminateAfter(long? terminateAfter) => Qs("terminate_after", terminateAfter);
		///<summary>Specific 'tag' of the request for logging and statistical purposes</summary>
		public DeleteByQueryDescriptor<T> Stats(params string[] stats) => Qs("stats", stats);
		///<summary>Specify whether to return document version as part of a hit</summary>
		public DeleteByQueryDescriptor<T> Version(bool? version = true) => Qs("version", version);
		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public DeleteByQueryDescriptor<T> RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
		///<summary>Should the effected indexes be refreshed?</summary>
		public DeleteByQueryDescriptor<T> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>Time each individual bulk request should wait for shards that are unavailable.</summary>
		public DeleteByQueryDescriptor<T> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Sets the number of shard copies that must be active before proceeding with the delete by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public DeleteByQueryDescriptor<T> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>Size on the scroll request powering the delete by query</summary>
		public DeleteByQueryDescriptor<T> ScrollSize(long? scrollSize) => Qs("scroll_size", scrollSize);
		///<summary>Should the request should block until the delete by query is complete.</summary>
		public DeleteByQueryDescriptor<T> WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
		///<summary>The throttle for this request in sub-requests per second. -1 means no throttle.</summary>
		public DeleteByQueryDescriptor<T> RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
		///<summary>The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.</summary>
		public DeleteByQueryDescriptor<T> Slices(long? slices) => Qs("slices", slices);
	}
	///<summary>descriptor for DeleteByQueryRethrottle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html</pre></summary>
	public partial class DeleteByQueryRethrottleDescriptor  : RequestDescriptorBase<DeleteByQueryRethrottleDescriptor,DeleteByQueryRethrottleRequestParameters, IDeleteByQueryRethrottleRequest>, IDeleteByQueryRethrottleRequest
	{ 
		/// <summary>/_delete_by_query/{task_id}/_rethrottle</summary>
		///<param name="task_id"> this parameter is required</param>
		public DeleteByQueryRethrottleDescriptor(TaskId task_id) : base(r=>r.Required("task_id", task_id)){}
		// values part of the url path
		TaskId IDeleteByQueryRethrottleRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");

		// Request parameters

		///<summary>The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.</summary>
		public DeleteByQueryRethrottleDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
	}
	///<summary>descriptor for DeleteScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class DeleteScriptDescriptor  : RequestDescriptorBase<DeleteScriptDescriptor,DeleteScriptRequestParameters, IDeleteScriptRequest>, IDeleteScriptRequest
	{ 
		/// <summary>/_scripts/{id}</summary>
		///<param name="id"> this parameter is required</param>
		public DeleteScriptDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id IDeleteScriptRequest.Id => Self.RouteValues.Get<Id>("id");

		// Request parameters

		///<summary>Explicit operation timeout</summary>
		public DeleteScriptDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public DeleteScriptDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for Exists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class DocumentExistsDescriptor<T>  : RequestDescriptorBase<DocumentExistsDescriptor<T>,DocumentExistsRequestParameters, IDocumentExistsRequest>, IDocumentExistsRequest
	{ 
		/// <summary>/{index}/{type}/{id}</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="type"> this parameter is required</param>
		///<param name="id"> this parameter is required</param>
		public DocumentExistsDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id))
		=> Q("routing", new Routing(() => AutoRouteDocument()));
		/// <summary>/{index}/{type}/{id}</summary>
		///<param name="document"> describes an elasticsearch document of type <typeparamref name="T"/> from which the index, type and id can be inferred</param>
		public DocumentExistsDescriptor(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id))
		{ this.DocumentFromPath(document.Document); Q("routing", new Routing(() => AutoRouteDocument() ?? document.Document));}
		partial void DocumentFromPath(T document);
		// values part of the url path
		Id IDocumentExistsRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IDocumentExistsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IDocumentExistsRequest.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>The name of the index</summary>
		public DocumentExistsDescriptor<T> Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DocumentExistsDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		///<summary>The type of the document (use `_all` to fetch the first document matching the ID across all types)</summary>
		public DocumentExistsDescriptor<T> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Required("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public DocumentExistsDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("type", (TypeName)v));

		// Request parameters

		///<summary>A comma-separated list of stored fields to return in the response</summary>
		public DocumentExistsDescriptor<T> StoredFields(Fields storedFields) => Qs("stored_fields", storedFields);
		///<summary>A comma-separated list of stored fields to return in the response</summary>
		public DocumentExistsDescriptor<T> StoredFields(params Expression<Func<T, object>>[] fields)  => Qs("stored_fields", fields?.Select(e=>(Field)e));

		///<summary>The ID of the parent document</summary>
		[Obsolete("Scheduled to be removed in 7.0, the parent parameter has been deprecated from elasticsearch, please use routing instead directly.")]
		public DocumentExistsDescriptor<T> Parent(string parent) => Qs("parent", parent);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public DocumentExistsDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public DocumentExistsDescriptor<T> Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public DocumentExistsDescriptor<T> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public DocumentExistsDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public DocumentExistsDescriptor<T> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public DocumentExistsDescriptor<T> SourceExclude(Fields sourceExclude) => Qs("_source_excludes", sourceExclude);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public DocumentExistsDescriptor<T> SourceExclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_excludes", fields?.Select(e=>(Field)e));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public DocumentExistsDescriptor<T> SourceInclude(Fields sourceInclude) => Qs("_source_includes", sourceInclude);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public DocumentExistsDescriptor<T> SourceInclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_includes", fields?.Select(e=>(Field)e));

		///<summary>Explicit version number for concurrency control</summary>
		public DocumentExistsDescriptor<T> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public DocumentExistsDescriptor<T> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}
	///<summary>descriptor for ExistsSource <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class SourceExistsDescriptor<T>  : RequestDescriptorBase<SourceExistsDescriptor<T>,SourceExistsRequestParameters, ISourceExistsRequest>, ISourceExistsRequest
	{ 
		/// <summary>/{index}/{type}/{id}/_source</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="type"> this parameter is required</param>
		///<param name="id"> this parameter is required</param>
		public SourceExistsDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id))
		=> Q("routing", new Routing(() => AutoRouteDocument()));
		/// <summary>/{index}/{type}/{id}/_source</summary>
		///<param name="document"> describes an elasticsearch document of type <typeparamref name="T"/> from which the index, type and id can be inferred</param>
		public SourceExistsDescriptor(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id))
		{ this.DocumentFromPath(document.Document); Q("routing", new Routing(() => AutoRouteDocument() ?? document.Document));}
		partial void DocumentFromPath(T document);
		// values part of the url path
		Id ISourceExistsRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName ISourceExistsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName ISourceExistsRequest.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>The name of the index</summary>
		public SourceExistsDescriptor<T> Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SourceExistsDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		///<summary>The type of the document; use `_all` to fetch the first document matching the ID across all types</summary>
		public SourceExistsDescriptor<T> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Required("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public SourceExistsDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("type", (TypeName)v));

		// Request parameters

		///<summary>The ID of the parent document</summary>
		[Obsolete("Scheduled to be removed in 7.0, the parent parameter has been deprecated from elasticsearch, please use routing instead directly.")]
		public SourceExistsDescriptor<T> Parent(string parent) => Qs("parent", parent);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SourceExistsDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public SourceExistsDescriptor<T> Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public SourceExistsDescriptor<T> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public SourceExistsDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public SourceExistsDescriptor<T> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceExistsDescriptor<T> SourceExclude(Fields sourceExclude) => Qs("_source_excludes", sourceExclude);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceExistsDescriptor<T> SourceExclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_excludes", fields?.Select(e=>(Field)e));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceExistsDescriptor<T> SourceInclude(Fields sourceInclude) => Qs("_source_includes", sourceInclude);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceExistsDescriptor<T> SourceInclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_includes", fields?.Select(e=>(Field)e));

		///<summary>Explicit version number for concurrency control</summary>
		public SourceExistsDescriptor<T> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public SourceExistsDescriptor<T> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}
	///<summary>descriptor for Explain <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-explain.html</pre></summary>
	public partial class ExplainDescriptor<TDocument>  : RequestDescriptorBase<ExplainDescriptor<TDocument>,ExplainRequestParameters, IExplainRequest<TDocument>>, IExplainRequest<TDocument>
	{ 
		/// <summary>/{index}/{type}/{id}/_explain</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="type"> this parameter is required</param>
		///<param name="id"> this parameter is required</param>
		public ExplainDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id))
		=> Q("routing", new Routing(() => AutoRouteDocument()));
		/// <summary>/{index}/{type}/{id}/_explain</summary>
		///<param name="document"> describes an elasticsearch document of type <typeparamref name="TDocument"/> from which the index, type and id can be inferred</param>
		public ExplainDescriptor(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id))
		{ this.DocumentFromPath(document.Document); Q("routing", new Routing(() => AutoRouteDocument() ?? document.Document));}
		partial void DocumentFromPath(TDocument document);
		// values part of the url path
		Id IExplainRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
		IndexName IExplainRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IExplainRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>The name of the index</summary>
		public ExplainDescriptor<TDocument> Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ExplainDescriptor<TDocument> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		///<summary>The type of the document</summary>
		public ExplainDescriptor<TDocument> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Required("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public ExplainDescriptor<TDocument> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("type", (TypeName)v));

		// Request parameters

		///<summary>Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)</summary>
		public ExplainDescriptor<TDocument> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The analyzer for the query string query</summary>
		public ExplainDescriptor<TDocument> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public ExplainDescriptor<TDocument> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The default field for query string query (default: _all)</summary>
		public ExplainDescriptor<TDocument> Df(string df) => Qs("df", df);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public ExplainDescriptor<TDocument> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>The ID of the parent document</summary>
		[Obsolete("Scheduled to be removed in 7.0, the parent parameter has been deprecated from elasticsearch, please use routing instead directly.")]
		public ExplainDescriptor<TDocument> Parent(string parent) => Qs("parent", parent);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public ExplainDescriptor<TDocument> Preference(string preference) => Qs("preference", preference);
		///<summary>Query in the Lucene query string syntax</summary>
		public ExplainDescriptor<TDocument> QueryOnQueryString(string queryOnQueryString) => Qs("q", queryOnQueryString);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public ExplainDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public ExplainDescriptor<TDocument> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public ExplainDescriptor<TDocument> SourceExclude(Fields sourceExclude) => Qs("_source_excludes", sourceExclude);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public ExplainDescriptor<TDocument> SourceExclude(params Expression<Func<TDocument, object>>[] fields)  => Qs("_source_excludes", fields?.Select(e=>(Field)e));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public ExplainDescriptor<TDocument> SourceInclude(Fields sourceInclude) => Qs("_source_includes", sourceInclude);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public ExplainDescriptor<TDocument> SourceInclude(params Expression<Func<TDocument, object>>[] fields)  => Qs("_source_includes", fields?.Select(e=>(Field)e));

	}
	///<summary>descriptor for FieldCaps <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-caps.html</pre></summary>
	public partial class FieldCapabilitiesDescriptor  : RequestDescriptorBase<FieldCapabilitiesDescriptor,FieldCapabilitiesRequestParameters, IFieldCapabilitiesRequest>, IFieldCapabilitiesRequest
	{ 
		/// <summary>/_field_caps</summary>
		public FieldCapabilitiesDescriptor() : base(){}
		// values part of the url path
		Indices IFieldCapabilitiesRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public FieldCapabilitiesDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public FieldCapabilitiesDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public FieldCapabilitiesDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>A comma-separated list of field names</summary>
		public FieldCapabilitiesDescriptor Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of field names</summary>
		public FieldCapabilitiesDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("fields", fields?.Select(e=>(Field)e));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public FieldCapabilitiesDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public FieldCapabilitiesDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public FieldCapabilitiesDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	}
	///<summary>descriptor for Get <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class GetDescriptor<T>  : RequestDescriptorBase<GetDescriptor<T>,GetRequestParameters, IGetRequest>, IGetRequest
	{ 
		/// <summary>/{index}/{type}/{id}</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="type"> this parameter is required</param>
		///<param name="id"> this parameter is required</param>
		public GetDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id))
		=> Q("routing", new Routing(() => AutoRouteDocument()));
		/// <summary>/{index}/{type}/{id}</summary>
		///<param name="document"> describes an elasticsearch document of type <typeparamref name="T"/> from which the index, type and id can be inferred</param>
		public GetDescriptor(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id))
		{ this.DocumentFromPath(document.Document); Q("routing", new Routing(() => AutoRouteDocument() ?? document.Document));}
		partial void DocumentFromPath(T document);
		// values part of the url path
		Id IGetRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IGetRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IGetRequest.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>The name of the index</summary>
		public GetDescriptor<T> Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		///<summary>The type of the document (use `_all` to fetch the first document matching the ID across all types)</summary>
		public GetDescriptor<T> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Required("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public GetDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("type", (TypeName)v));

		// Request parameters

		///<summary>A comma-separated list of stored fields to return in the response</summary>
		public GetDescriptor<T> StoredFields(Fields storedFields) => Qs("stored_fields", storedFields);
		///<summary>A comma-separated list of stored fields to return in the response</summary>
		public GetDescriptor<T> StoredFields(params Expression<Func<T, object>>[] fields)  => Qs("stored_fields", fields?.Select(e=>(Field)e));

		///<summary>The ID of the parent document</summary>
		[Obsolete("Scheduled to be removed in 7.0, the parent parameter has been deprecated from elasticsearch, please use routing instead directly.")]
		public GetDescriptor<T> Parent(string parent) => Qs("parent", parent);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public GetDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public GetDescriptor<T> Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public GetDescriptor<T> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public GetDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public GetDescriptor<T> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public GetDescriptor<T> SourceExclude(Fields sourceExclude) => Qs("_source_exclude", sourceExclude);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public GetDescriptor<T> SourceExclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_exclude", fields?.Select(e=>(Field)e));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public GetDescriptor<T> SourceInclude(Fields sourceInclude) => Qs("_source_include", sourceInclude);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public GetDescriptor<T> SourceInclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_include", fields?.Select(e=>(Field)e));

		///<summary>Explicit version number for concurrency control</summary>
		public GetDescriptor<T> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public GetDescriptor<T> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}
	///<summary>descriptor for GetScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class GetScriptDescriptor  : RequestDescriptorBase<GetScriptDescriptor,GetScriptRequestParameters, IGetScriptRequest>, IGetScriptRequest
	{ 
		/// <summary>/_scripts/{id}</summary>
		///<param name="id"> this parameter is required</param>
		public GetScriptDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id IGetScriptRequest.Id => Self.RouteValues.Get<Id>("id");

		// Request parameters

		///<summary>Specify timeout for connection to master</summary>
		public GetScriptDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for GetSource <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class SourceDescriptor<T>  : RequestDescriptorBase<SourceDescriptor<T>,SourceRequestParameters, ISourceRequest>, ISourceRequest
	{ 
		/// <summary>/{index}/{type}/{id}/_source</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="type"> this parameter is required</param>
		///<param name="id"> this parameter is required</param>
		public SourceDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id))
		=> Q("routing", new Routing(() => AutoRouteDocument()));
		/// <summary>/{index}/{type}/{id}/_source</summary>
		///<param name="document"> describes an elasticsearch document of type <typeparamref name="T"/> from which the index, type and id can be inferred</param>
		public SourceDescriptor(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id))
		{ this.DocumentFromPath(document.Document); Q("routing", new Routing(() => AutoRouteDocument() ?? document.Document));}
		partial void DocumentFromPath(T document);
		// values part of the url path
		Id ISourceRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName ISourceRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName ISourceRequest.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>The name of the index</summary>
		public SourceDescriptor<T> Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SourceDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		///<summary>The type of the document; use `_all` to fetch the first document matching the ID across all types</summary>
		public SourceDescriptor<T> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Required("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public SourceDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("type", (TypeName)v));

		// Request parameters

		///<summary>The ID of the parent document</summary>
		[Obsolete("Scheduled to be removed in 7.0, the parent parameter has been deprecated from elasticsearch, please use routing instead directly.")]
		public SourceDescriptor<T> Parent(string parent) => Qs("parent", parent);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SourceDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public SourceDescriptor<T> Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public SourceDescriptor<T> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public SourceDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public SourceDescriptor<T> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceDescriptor<T> SourceExclude(Fields sourceExclude) => Qs("_source_excludes", sourceExclude);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceDescriptor<T> SourceExclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_excludes", fields?.Select(e=>(Field)e));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceDescriptor<T> SourceInclude(Fields sourceInclude) => Qs("_source_includes", sourceInclude);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceDescriptor<T> SourceInclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_includes", fields?.Select(e=>(Field)e));

		///<summary>Explicit version number for concurrency control</summary>
		public SourceDescriptor<T> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public SourceDescriptor<T> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}
	///<summary>descriptor for Index <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html</pre></summary>
	public partial class IndexDescriptor<TDocument>  : RequestDescriptorBase<IndexDescriptor<TDocument>,IndexRequestParameters, IIndexRequest<TDocument>>, IIndexRequest<TDocument>
	{ 
		/// <summary>/{index}/{type}</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="type"> this parameter is required</param>
		public IndexDescriptor(IndexName index, TypeName type) : base(r=>r.Required("index", index).Required("type", type))
		=> Q("routing", new Routing(() => AutoRouteDocument()));
		/// <summary>/{index}/{type}</summary>
		///<param name="document"> describes an elasticsearch document of type <typeparamref name="TDocument"/> from which the index, type and id can be inferred</param>
		public IndexDescriptor(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id))
		{ this.DocumentFromPath(document.Document); Q("routing", new Routing(() => AutoRouteDocument() ?? document.Document));}
		partial void DocumentFromPath(TDocument document);
		// values part of the url path
		Id IIndexRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
		IndexName IIndexRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IIndexRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>Document ID</summary>
		public IndexDescriptor<TDocument> Id(Id id) => Assign(id, (a,v)=>a.RouteValues.Optional("id", v));

		///<summary>The name of the index</summary>
		public IndexDescriptor<TDocument> Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public IndexDescriptor<TDocument> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		///<summary>The type of the document</summary>
		public IndexDescriptor<TDocument> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Required("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public IndexDescriptor<TDocument> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("type", (TypeName)v));

		// Request parameters

		///<summary>Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public IndexDescriptor<TDocument> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>Explicit operation type</summary>
		public IndexDescriptor<TDocument> OpType(OpType? opType) => Qs("op_type", opType);
		///<summary>ID of the parent document</summary>
		[Obsolete("Scheduled to be removed in 7.0, the parent parameter has been deprecated from elasticsearch, please use routing instead directly.")]
		public IndexDescriptor<TDocument> Parent(string parent) => Qs("parent", parent);
		///<summary>If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.</summary>
		public IndexDescriptor<TDocument> Refresh(Refresh? refresh) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public IndexDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Explicit operation timeout</summary>
		public IndexDescriptor<TDocument> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Explicit version number for concurrency control</summary>
		public IndexDescriptor<TDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public IndexDescriptor<TDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
		///<summary>only perform the index operation if the last operation that has changed the document has the specified sequence number</summary>
		public IndexDescriptor<TDocument> IfSeqNo(long? ifSeqNo) => Qs("if_seq_no", ifSeqNo);
		///<summary>only perform the index operation if the last operation that has changed the document has the specified primary term</summary>
		public IndexDescriptor<TDocument> IfPrimaryTerm(long? ifPrimaryTerm) => Qs("if_primary_term", ifPrimaryTerm);
		///<summary>The pipeline id to preprocess incoming documents with</summary>
		public IndexDescriptor<TDocument> Pipeline(string pipeline) => Qs("pipeline", pipeline);
	}
	///<summary>descriptor for IndicesAnalyzeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-analyze.html</pre></summary>
	public partial class AnalyzeDescriptor  : RequestDescriptorBase<AnalyzeDescriptor,AnalyzeRequestParameters, IAnalyzeRequest>, IAnalyzeRequest
	{ 
		/// <summary>/_analyze</summary>
		public AnalyzeDescriptor() : base(){}
		// values part of the url path
		IndexName IAnalyzeRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The name of the index to scope the operation</summary>
		public AnalyzeDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public AnalyzeDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (IndexName)v));

		// Request parameters

		///<summary>With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)</summary>
		[Obsolete("Scheduled to be removed in 7.0, Erroneously documented as a valid option, no longer document from 6.4 onwards as per https://github.com/elastic/elasticsearch/pull/31795")]
		public AnalyzeDescriptor PreferLocal(bool? preferLocal = true) => Qs("prefer_local", preferLocal);
		///<summary>Format of the output</summary>
		[Obsolete("Scheduled to be removed in 7.0, Erroneously documented as a valid option, no longer document from 6.4 onwards as per https://github.com/elastic/elasticsearch/pull/31795")]
		public AnalyzeDescriptor Format(Format? format) => Qs("format", format);
	}
	///<summary>descriptor for IndicesClearCacheForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-clearcache.html</pre></summary>
	public partial class ClearCacheDescriptor  : RequestDescriptorBase<ClearCacheDescriptor,ClearCacheRequestParameters, IClearCacheRequest>, IClearCacheRequest
	{ 
		/// <summary>/_cache/clear</summary>
		public ClearCacheDescriptor() : base(){}
		// values part of the url path
		Indices IClearCacheRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index name to limit the operation</summary>
		public ClearCacheDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ClearCacheDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public ClearCacheDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Clear field data</summary>
		public ClearCacheDescriptor Fielddata(bool? fielddata = true) => Qs("fielddata", fielddata);
		///<summary>A comma-separated list of fields to clear when using the `fielddata` parameter (default: all)</summary>
		public ClearCacheDescriptor Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of fields to clear when using the `fielddata` parameter (default: all)</summary>
		public ClearCacheDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("fields", fields?.Select(e=>(Field)e));

		///<summary>Clear query caches</summary>
		public ClearCacheDescriptor Query(bool? query = true) => Qs("query", query);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ClearCacheDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ClearCacheDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ClearCacheDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Clear request cache</summary>
		public ClearCacheDescriptor RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
		///<summary>Clear request cache</summary>
		public ClearCacheDescriptor Request(bool? request = true) => Qs("request", request);
		///<summary>Clear the recycle cache</summary>
		[Obsolete("Scheduled to be removed in 7.0, Removed in 6.3.0 from the server see https://github.com/elastic/elasticsearch/pull/28866")]
		public ClearCacheDescriptor Recycler(bool? recycler = true) => Qs("recycler", recycler);
	}
	///<summary>descriptor for IndicesClose <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html</pre></summary>
	public partial class CloseIndexDescriptor  : RequestDescriptorBase<CloseIndexDescriptor,CloseIndexRequestParameters, ICloseIndexRequest>, ICloseIndexRequest
	{ 
		/// <summary>/{index}/_close</summary>
		///<param name="index"> this parameter is required</param>
		public CloseIndexDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		Indices ICloseIndexRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma separated list of indices to close</summary>
		public CloseIndexDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CloseIndexDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CloseIndexDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Explicit operation timeout</summary>
		public CloseIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public CloseIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public CloseIndexDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public CloseIndexDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public CloseIndexDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	}
	///<summary>descriptor for IndicesCreate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-create-index.html</pre></summary>
	public partial class CreateIndexDescriptor  : RequestDescriptorBase<CreateIndexDescriptor,CreateIndexRequestParameters, ICreateIndexRequest>, ICreateIndexRequest
	{ 
		/// <summary>/{index}</summary>
		///<param name="index"> this parameter is required</param>
		public CreateIndexDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		IndexName ICreateIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The name of the index</summary>
		public CreateIndexDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CreateIndexDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

		///<summary>Whether a type should be expected in the body of the mappings.</summary>
		public CreateIndexDescriptor IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Set the number of active shards to wait for before the operation returns.</summary>
		public CreateIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>Explicit operation timeout</summary>
		public CreateIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public CreateIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Whether to update the mapping for all fields with the same name across all types or not</summary>
		[Obsolete("Scheduled to be removed in 7.0, Elasticsearch 6.x only allows a single type per index so this parameter is now useless")]
		public CreateIndexDescriptor UpdateAllTypes(bool? updateAllTypes = true) => Qs("update_all_types", updateAllTypes);
	}
	///<summary>descriptor for IndicesDelete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-delete-index.html</pre></summary>
	public partial class DeleteIndexDescriptor  : RequestDescriptorBase<DeleteIndexDescriptor,DeleteIndexRequestParameters, IDeleteIndexRequest>, IDeleteIndexRequest
	{ 
		/// <summary>/{index}</summary>
		///<param name="index"> this parameter is required</param>
		public DeleteIndexDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		Indices IDeleteIndexRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices</summary>
		public DeleteIndexDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DeleteIndexDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public DeleteIndexDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Explicit operation timeout</summary>
		public DeleteIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public DeleteIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Ignore unavailable indexes (default: false)</summary>
		public DeleteIndexDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Ignore if a wildcard expression resolves to no concrete indices (default: false)</summary>
		public DeleteIndexDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether wildcard expressions should get expanded to open or closed indices (default: open)</summary>
		public DeleteIndexDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	}
	///<summary>descriptor for IndicesDeleteAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class DeleteAliasDescriptor  : RequestDescriptorBase<DeleteAliasDescriptor,DeleteAliasRequestParameters, IDeleteAliasRequest>, IDeleteAliasRequest
	{ 
		/// <summary>/{index}/_alias/{name}</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="name"> this parameter is required</param>
		public DeleteAliasDescriptor(Indices index, Names name) : base(r=>r.Required("index", index).Required("name", name)){}
		// values part of the url path
		Indices IDeleteAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IDeleteAliasRequest.Name => Self.RouteValues.Get<Names>("name");

		///<summary>A comma-separated list of index names (supports wildcards); use `_all` for all indices</summary>
		public DeleteAliasDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DeleteAliasDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public DeleteAliasDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Explicit timestamp for the document</summary>
		public DeleteAliasDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public DeleteAliasDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for IndicesDeleteTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class DeleteIndexTemplateDescriptor  : RequestDescriptorBase<DeleteIndexTemplateDescriptor,DeleteIndexTemplateRequestParameters, IDeleteIndexTemplateRequest>, IDeleteIndexTemplateRequest
	{ 
		/// <summary>/_template/{name}</summary>
		///<param name="name"> this parameter is required</param>
		public DeleteIndexTemplateDescriptor(Name name) : base(r=>r.Required("name", name)){}
		// values part of the url path
		Name IDeleteIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");

		// Request parameters

		///<summary>Explicit operation timeout</summary>
		public DeleteIndexTemplateDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public DeleteIndexTemplateDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for IndicesExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-exists.html</pre></summary>
	public partial class IndexExistsDescriptor  : RequestDescriptorBase<IndexExistsDescriptor,IndexExistsRequestParameters, IIndexExistsRequest>, IIndexExistsRequest
	{ 
		/// <summary>/{index}</summary>
		///<param name="index"> this parameter is required</param>
		public IndexExistsDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		Indices IIndexExistsRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names</summary>
		public IndexExistsDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public IndexExistsDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public IndexExistsDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndexExistsDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Ignore unavailable indexes (default: false)</summary>
		public IndexExistsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Ignore if a wildcard expression resolves to no concrete indices (default: false)</summary>
		public IndexExistsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether wildcard expressions should get expanded to open or closed indices (default: open)</summary>
		public IndexExistsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return settings in flat format (default: false)</summary>
		public IndexExistsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Whether to return all default setting for each of the indices.</summary>
		public IndexExistsDescriptor IncludeDefaults(bool? includeDefaults = true) => Qs("include_defaults", includeDefaults);
	}
	///<summary>descriptor for IndicesExistsAliasForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class AliasExistsDescriptor  : RequestDescriptorBase<AliasExistsDescriptor,AliasExistsRequestParameters, IAliasExistsRequest>, IAliasExistsRequest
	{ 
		/// <summary>/_alias/{name}</summary>
		///<param name="name"> this parameter is required</param>
		public AliasExistsDescriptor(Names name) : base(r=>r.Required("name", name)){}
		// values part of the url path
		Indices IAliasExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IAliasExistsRequest.Name => Self.RouteValues.Get<Names>("name");

		///<summary>A comma-separated list of index names to filter aliases</summary>
		public AliasExistsDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public AliasExistsDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public AliasExistsDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public AliasExistsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public AliasExistsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public AliasExistsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public AliasExistsDescriptor Local(bool? local = true) => Qs("local", local);
	}
	///<summary>descriptor for IndicesExistsTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class IndexTemplateExistsDescriptor  : RequestDescriptorBase<IndexTemplateExistsDescriptor,IndexTemplateExistsRequestParameters, IIndexTemplateExistsRequest>, IIndexTemplateExistsRequest
	{ 
		/// <summary>/_template/{name}</summary>
		///<param name="name"> this parameter is required</param>
		public IndexTemplateExistsDescriptor(Names name) : base(r=>r.Required("name", name)){}
		// values part of the url path
		Names IIndexTemplateExistsRequest.Name => Self.RouteValues.Get<Names>("name");

		// Request parameters

		///<summary>Return settings in flat format (default: false)</summary>
		public IndexTemplateExistsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public IndexTemplateExistsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndexTemplateExistsDescriptor Local(bool? local = true) => Qs("local", local);
	}
	///<summary>descriptor for IndicesExistsType <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-types-exists.html</pre></summary>
	public partial class TypeExistsDescriptor  : RequestDescriptorBase<TypeExistsDescriptor,TypeExistsRequestParameters, ITypeExistsRequest>, ITypeExistsRequest
	{ 
		/// <summary>/{index}/_mapping/{type}</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="type"> this parameter is required</param>
		public TypeExistsDescriptor(Indices index, Types type) : base(r=>r.Required("index", index).Required("type", type)){}
		// values part of the url path
		Indices ITypeExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ITypeExistsRequest.Type => Self.RouteValues.Get<Types>("type");

		///<summary>A comma-separated list of index names; use `_all` to check the types across all indices</summary>
		public TypeExistsDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public TypeExistsDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public TypeExistsDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to check</summary>
		public TypeExistsDescriptor Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Required("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public TypeExistsDescriptor Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public TypeExistsDescriptor AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public TypeExistsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public TypeExistsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public TypeExistsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public TypeExistsDescriptor Local(bool? local = true) => Qs("local", local);
	}
	///<summary>descriptor for IndicesFlushForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-flush.html</pre></summary>
	public partial class FlushDescriptor  : RequestDescriptorBase<FlushDescriptor,FlushRequestParameters, IFlushRequest>, IFlushRequest
	{ 
		/// <summary>/_flush</summary>
		public FlushDescriptor() : base(){}
		// values part of the url path
		Indices IFlushRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All for all indices</summary>
		public FlushDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public FlushDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public FlushDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)</summary>
		public FlushDescriptor Force(bool? force = true) => Qs("force", force);
		///<summary>If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is true. If set to false the flush will be skipped iff if another flush operation is already running.</summary>
		public FlushDescriptor WaitIfOngoing(bool? waitIfOngoing = true) => Qs("wait_if_ongoing", waitIfOngoing);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public FlushDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public FlushDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public FlushDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	}
	///<summary>descriptor for IndicesFlushSyncedForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-synced-flush.html</pre></summary>
	public partial class SyncedFlushDescriptor  : RequestDescriptorBase<SyncedFlushDescriptor,SyncedFlushRequestParameters, ISyncedFlushRequest>, ISyncedFlushRequest
	{ 
		/// <summary>/_flush/synced</summary>
		public SyncedFlushDescriptor() : base(){}
		// values part of the url path
		Indices ISyncedFlushRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All for all indices</summary>
		public SyncedFlushDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SyncedFlushDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public SyncedFlushDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SyncedFlushDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SyncedFlushDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SyncedFlushDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	}
	///<summary>descriptor for IndicesForcemergeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-forcemerge.html</pre></summary>
	public partial class ForceMergeDescriptor  : RequestDescriptorBase<ForceMergeDescriptor,ForceMergeRequestParameters, IForceMergeRequest>, IForceMergeRequest
	{ 
		/// <summary>/_forcemerge</summary>
		public ForceMergeDescriptor() : base(){}
		// values part of the url path
		Indices IForceMergeRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public ForceMergeDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ForceMergeDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public ForceMergeDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Specify whether the index should be flushed after performing the operation (default: true)</summary>
		public ForceMergeDescriptor Flush(bool? flush = true) => Qs("flush", flush);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ForceMergeDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ForceMergeDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ForceMergeDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>The number of segments the index should be merged into (default: dynamic)</summary>
		public ForceMergeDescriptor MaxNumSegments(long? maxNumSegments) => Qs("max_num_segments", maxNumSegments);
		///<summary>Specify whether the operation should only expunge deleted documents</summary>
		public ForceMergeDescriptor OnlyExpungeDeletes(bool? onlyExpungeDeletes = true) => Qs("only_expunge_deletes", onlyExpungeDeletes);
	}
	///<summary>descriptor for IndicesGet <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-index.html</pre></summary>
	public partial class GetIndexDescriptor  : RequestDescriptorBase<GetIndexDescriptor,GetIndexRequestParameters, IGetIndexRequest>, IGetIndexRequest
	{ 
		/// <summary>/{index}</summary>
		///<param name="index"> this parameter is required</param>
		public GetIndexDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		Indices IGetIndexRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names</summary>
		public GetIndexDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetIndexDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GetIndexDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Whether to add the type name to the response (default: true)</summary>
		public GetIndexDescriptor IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetIndexDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Ignore unavailable indexes (default: false)</summary>
		public GetIndexDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Ignore if a wildcard expression resolves to no concrete indices (default: false)</summary>
		public GetIndexDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether wildcard expressions should get expanded to open or closed indices (default: open)</summary>
		public GetIndexDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return settings in flat format (default: false)</summary>
		public GetIndexDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Whether to return all default setting for each of the indices.</summary>
		public GetIndexDescriptor IncludeDefaults(bool? includeDefaults = true) => Qs("include_defaults", includeDefaults);
		///<summary>Specify timeout for connection to master</summary>
		public GetIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for IndicesGetAliasForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class GetAliasDescriptor  : RequestDescriptorBase<GetAliasDescriptor,GetAliasRequestParameters, IGetAliasRequest>, IGetAliasRequest
	{ 
		/// <summary>/_alias</summary>
		public GetAliasDescriptor() : base(){}
		// values part of the url path
		Indices IGetAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IGetAliasRequest.Name => Self.RouteValues.Get<Names>("name");

		///<summary>A comma-separated list of index names to filter aliases</summary>
		public GetAliasDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetAliasDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GetAliasDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of alias names to return</summary>
		public GetAliasDescriptor Name(Names name) => Assign(name, (a,v)=>a.RouteValues.Optional("name", v));

		// Request parameters

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetAliasDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetAliasDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetAliasDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetAliasDescriptor Local(bool? local = true) => Qs("local", local);
	}
	///<summary>descriptor for IndicesGetFieldMappingForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-field-mapping.html</pre></summary>
	public partial class GetFieldMappingDescriptor<T>  : RequestDescriptorBase<GetFieldMappingDescriptor<T>,GetFieldMappingRequestParameters, IGetFieldMappingRequest>, IGetFieldMappingRequest
	{ 
		/// <summary>/_mapping/field/{fields}</summary>
		///<param name="fields"> this parameter is required</param>
		public GetFieldMappingDescriptor(Fields fields) : base(r=>r.Required("fields", fields)){}
		// values part of the url path
		Indices IGetFieldMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IGetFieldMappingRequest.Type => Self.RouteValues.Get<Types>("type");
		Fields IGetFieldMappingRequest.Fields => Self.RouteValues.Get<Fields>("fields");

		///<summary>A comma-separated list of index names</summary>
		public GetFieldMappingDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetFieldMappingDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GetFieldMappingDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types</summary>
		public GetFieldMappingDescriptor<T> Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public GetFieldMappingDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public GetFieldMappingDescriptor<T> AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>Whether a type should be returned in the body of the mappings.</summary>
		public GetFieldMappingDescriptor<T> IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Whether the default mapping values should be returned as well</summary>
		public GetFieldMappingDescriptor<T> IncludeDefaults(bool? includeDefaults = true) => Qs("include_defaults", includeDefaults);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetFieldMappingDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetFieldMappingDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetFieldMappingDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetFieldMappingDescriptor<T> Local(bool? local = true) => Qs("local", local);
	}
	///<summary>descriptor for IndicesGetMappingForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-mapping.html</pre></summary>
	public partial class GetMappingDescriptor<T>  : RequestDescriptorBase<GetMappingDescriptor<T>,GetMappingRequestParameters, IGetMappingRequest>, IGetMappingRequest
	{ 
		/// <summary>/_mapping</summary>
		public GetMappingDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		// values part of the url path
		Indices IGetMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IGetMappingRequest.Type => Self.RouteValues.Get<Types>("type");

		///<summary>A comma-separated list of index names</summary>
		public GetMappingDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetMappingDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GetMappingDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types</summary>
		public GetMappingDescriptor<T> Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public GetMappingDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public GetMappingDescriptor<T> AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>Whether to add the type name to the response.</summary>
		public GetMappingDescriptor<T> IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetMappingDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetMappingDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetMappingDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Specify timeout for connection to master</summary>
		public GetMappingDescriptor<T> MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetMappingDescriptor<T> Local(bool? local = true) => Qs("local", local);
	}
	///<summary>descriptor for IndicesGetSettingsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-settings.html</pre></summary>
	public partial class GetIndexSettingsDescriptor  : RequestDescriptorBase<GetIndexSettingsDescriptor,GetIndexSettingsRequestParameters, IGetIndexSettingsRequest>, IGetIndexSettingsRequest
	{ 
		/// <summary>/_settings</summary>
		public GetIndexSettingsDescriptor() : base(){}
		// values part of the url path
		Indices IGetIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IGetIndexSettingsRequest.Name => Self.RouteValues.Get<Names>("name");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public GetIndexSettingsDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetIndexSettingsDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GetIndexSettingsDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>The name of the settings that should be included</summary>
		public GetIndexSettingsDescriptor Name(Names name) => Assign(name, (a,v)=>a.RouteValues.Optional("name", v));

		// Request parameters

		///<summary>Specify timeout for connection to master</summary>
		public GetIndexSettingsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetIndexSettingsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetIndexSettingsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetIndexSettingsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return settings in flat format (default: false)</summary>
		public GetIndexSettingsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetIndexSettingsDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Whether to return all default setting for each of the indices.</summary>
		public GetIndexSettingsDescriptor IncludeDefaults(bool? includeDefaults = true) => Qs("include_defaults", includeDefaults);
	}
	///<summary>descriptor for IndicesGetTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class GetIndexTemplateDescriptor  : RequestDescriptorBase<GetIndexTemplateDescriptor,GetIndexTemplateRequestParameters, IGetIndexTemplateRequest>, IGetIndexTemplateRequest
	{ 
		/// <summary>/_template</summary>
		public GetIndexTemplateDescriptor() : base(){}
		// values part of the url path
		Names IGetIndexTemplateRequest.Name => Self.RouteValues.Get<Names>("name");

		///<summary>The comma separated names of the index templates</summary>
		public GetIndexTemplateDescriptor Name(Names name) => Assign(name, (a,v)=>a.RouteValues.Optional("name", v));

		// Request parameters

		///<summary>Whether a type should be returned in the body of the mappings.</summary>
		public GetIndexTemplateDescriptor IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Return settings in flat format (default: false)</summary>
		public GetIndexTemplateDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetIndexTemplateDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetIndexTemplateDescriptor Local(bool? local = true) => Qs("local", local);
	}
	///<summary>descriptor for IndicesGetUpgradeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html</pre></summary>
	public partial class UpgradeStatusDescriptor  : RequestDescriptorBase<UpgradeStatusDescriptor,UpgradeStatusRequestParameters, IUpgradeStatusRequest>, IUpgradeStatusRequest
	{ 
		/// <summary>/_upgrade</summary>
		public UpgradeStatusDescriptor() : base(){}
		// values part of the url path
		Indices IUpgradeStatusRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public UpgradeStatusDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UpgradeStatusDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public UpgradeStatusDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpgradeStatusDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpgradeStatusDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpgradeStatusDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	}
	///<summary>descriptor for IndicesOpen <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html</pre></summary>
	public partial class OpenIndexDescriptor  : RequestDescriptorBase<OpenIndexDescriptor,OpenIndexRequestParameters, IOpenIndexRequest>, IOpenIndexRequest
	{ 
		/// <summary>/{index}/_open</summary>
		///<param name="index"> this parameter is required</param>
		public OpenIndexDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		Indices IOpenIndexRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma separated list of indices to open</summary>
		public OpenIndexDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public OpenIndexDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public OpenIndexDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Explicit operation timeout</summary>
		public OpenIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public OpenIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public OpenIndexDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public OpenIndexDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public OpenIndexDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Sets the number of active shards to wait for before the operation returns.</summary>
		public OpenIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}
	///<summary>descriptor for IndicesPutAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class PutAliasDescriptor  : RequestDescriptorBase<PutAliasDescriptor,PutAliasRequestParameters, IPutAliasRequest>, IPutAliasRequest
	{ 
		/// <summary>/{index}/_alias/{name}</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="name"> this parameter is required</param>
		public PutAliasDescriptor(Indices index, Name name) : base(r=>r.Required("index", index).Required("name", name)){}
		// values part of the url path
		Indices IPutAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		Name IPutAliasRequest.Name => Self.RouteValues.Get<Name>("name");

		///<summary>A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.</summary>
		public PutAliasDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public PutAliasDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public PutAliasDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Explicit timestamp for the document</summary>
		public PutAliasDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public PutAliasDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for IndicesPutMapping <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html</pre></summary>
	public partial class PutMappingDescriptor<T>  : RequestDescriptorBase<PutMappingDescriptor<T>,PutMappingRequestParameters, IPutMappingRequest>, IPutMappingRequest
	{ 
		/// <summary>/{index}/{type}/_mapping. Will infer the index and type from the generic type</summary>
		public PutMappingDescriptor() : this(typeof(T), typeof(T)){}
		// values part of the url path
		Indices IPutMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		TypeName IPutMappingRequest.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</summary>
		public PutMappingDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public PutMappingDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public PutMappingDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>The name of the document type</summary>
		public PutMappingDescriptor<T> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public PutMappingDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (TypeName)v));

		// Request parameters

		///<summary>Whether a type should be expected in the body of the mappings.</summary>
		public PutMappingDescriptor<T> IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Explicit operation timeout</summary>
		public PutMappingDescriptor<T> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public PutMappingDescriptor<T> MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public PutMappingDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public PutMappingDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public PutMappingDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether to update the mapping for all fields with the same name across all types or not</summary>
		[Obsolete("Scheduled to be removed in 7.0, Elasticsearch 6.x only allows a single type per index so this parameter is now useless")]
		public PutMappingDescriptor<T> UpdateAllTypes(bool? updateAllTypes = true) => Qs("update_all_types", updateAllTypes);
	}
	///<summary>descriptor for IndicesPutSettingsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-update-settings.html</pre></summary>
	public partial class UpdateIndexSettingsDescriptor  : RequestDescriptorBase<UpdateIndexSettingsDescriptor,UpdateIndexSettingsRequestParameters, IUpdateIndexSettingsRequest>, IUpdateIndexSettingsRequest
	{ 
		/// <summary>/_settings</summary>
		public UpdateIndexSettingsDescriptor() : base(){}
		// values part of the url path
		Indices IUpdateIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public UpdateIndexSettingsDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UpdateIndexSettingsDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public UpdateIndexSettingsDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Specify timeout for connection to master</summary>
		public UpdateIndexSettingsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public UpdateIndexSettingsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Whether to update existing settings. If set to `true` existing settings on an index remain unchanged, the default is `false`</summary>
		public UpdateIndexSettingsDescriptor PreserveExisting(bool? preserveExisting = true) => Qs("preserve_existing", preserveExisting);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpdateIndexSettingsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpdateIndexSettingsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpdateIndexSettingsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return settings in flat format (default: false)</summary>
		public UpdateIndexSettingsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
	}
	///<summary>descriptor for IndicesPutTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class PutIndexTemplateDescriptor  : RequestDescriptorBase<PutIndexTemplateDescriptor,PutIndexTemplateRequestParameters, IPutIndexTemplateRequest>, IPutIndexTemplateRequest
	{ 
		/// <summary>/_template/{name}</summary>
		///<param name="name"> this parameter is required</param>
		public PutIndexTemplateDescriptor(Name name) : base(r=>r.Required("name", name)){}
		// values part of the url path
		Name IPutIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");

		// Request parameters

		///<summary>Whether a type should be returned in the body of the mappings.</summary>
		public PutIndexTemplateDescriptor IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Whether the index template should only be added if new or can also replace an existing one</summary>
		public PutIndexTemplateDescriptor Create(bool? create = true) => Qs("create", create);
		///<summary>Explicit operation timeout</summary>
		public PutIndexTemplateDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public PutIndexTemplateDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Return settings in flat format (default: false)</summary>
		public PutIndexTemplateDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
	}
	///<summary>descriptor for IndicesRecoveryForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-recovery.html</pre></summary>
	public partial class RecoveryStatusDescriptor  : RequestDescriptorBase<RecoveryStatusDescriptor,RecoveryStatusRequestParameters, IRecoveryStatusRequest>, IRecoveryStatusRequest
	{ 
		/// <summary>/_recovery</summary>
		public RecoveryStatusDescriptor() : base(){}
		// values part of the url path
		Indices IRecoveryStatusRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public RecoveryStatusDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public RecoveryStatusDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public RecoveryStatusDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Whether to display detailed information about shard recovery</summary>
		public RecoveryStatusDescriptor Detailed(bool? detailed = true) => Qs("detailed", detailed);
		///<summary>Display only those recoveries that are currently on-going</summary>
		public RecoveryStatusDescriptor ActiveOnly(bool? activeOnly = true) => Qs("active_only", activeOnly);
	}
	///<summary>descriptor for IndicesRefreshForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-refresh.html</pre></summary>
	public partial class RefreshDescriptor  : RequestDescriptorBase<RefreshDescriptor,RefreshRequestParameters, IRefreshRequest>, IRefreshRequest
	{ 
		/// <summary>/_refresh</summary>
		public RefreshDescriptor() : base(){}
		// values part of the url path
		Indices IRefreshRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public RefreshDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public RefreshDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public RefreshDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public RefreshDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public RefreshDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public RefreshDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	}
	///<summary>descriptor for IndicesRolloverForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html</pre></summary>
	public partial class RolloverIndexDescriptor  : RequestDescriptorBase<RolloverIndexDescriptor,RolloverIndexRequestParameters, IRolloverIndexRequest>, IRolloverIndexRequest
	{ 
		/// <summary>/{alias}/_rollover</summary>
		///<param name="alias"> this parameter is required</param>
		public RolloverIndexDescriptor(Name alias) : base(r=>r.Required("alias", alias)){}
		// values part of the url path
		Name IRolloverIndexRequest.Alias => Self.RouteValues.Get<Name>("alias");
		IndexName IRolloverIndexRequest.NewIndex => Self.RouteValues.Get<IndexName>("new_index");

		///<summary>The name of the rollover index</summary>
		public RolloverIndexDescriptor NewIndex(IndexName newIndex) => Assign(newIndex, (a,v)=>a.RouteValues.Optional("new_index", v));

		// Request parameters

		///<summary>Whether a type should be included in the body of the mappings.</summary>
		public RolloverIndexDescriptor IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Explicit operation timeout</summary>
		public RolloverIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>If set to true the rollover action will only be validated but not actually performed even if a condition matches. The default is false</summary>
		public RolloverIndexDescriptor DryRun(bool? dryRun = true) => Qs("dry_run", dryRun);
		///<summary>Specify timeout for connection to master</summary>
		public RolloverIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Set the number of active shards to wait for on the newly created rollover index before the operation returns.</summary>
		public RolloverIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}
	///<summary>descriptor for IndicesSegmentsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-segments.html</pre></summary>
	public partial class SegmentsDescriptor  : RequestDescriptorBase<SegmentsDescriptor,SegmentsRequestParameters, ISegmentsRequest>, ISegmentsRequest
	{ 
		/// <summary>/_segments</summary>
		public SegmentsDescriptor() : base(){}
		// values part of the url path
		Indices ISegmentsRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public SegmentsDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SegmentsDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public SegmentsDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SegmentsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SegmentsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SegmentsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Includes detailed memory usage by Lucene.</summary>
		public SegmentsDescriptor Verbose(bool? verbose = true) => Qs("verbose", verbose);
	}
	///<summary>descriptor for IndicesShardStoresForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shards-stores.html</pre></summary>
	public partial class IndicesShardStoresDescriptor  : RequestDescriptorBase<IndicesShardStoresDescriptor,IndicesShardStoresRequestParameters, IIndicesShardStoresRequest>, IIndicesShardStoresRequest
	{ 
		/// <summary>/_shard_stores</summary>
		public IndicesShardStoresDescriptor() : base(){}
		// values part of the url path
		Indices IIndicesShardStoresRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public IndicesShardStoresDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public IndicesShardStoresDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public IndicesShardStoresDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>A comma-separated list of statuses used to filter on shards to get store information for</summary>
		public IndicesShardStoresDescriptor Status(params string[] status) => Qs("status", status);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndicesShardStoresDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndicesShardStoresDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndicesShardStoresDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	}
	///<summary>descriptor for IndicesShrink <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shrink-index.html</pre></summary>
	public partial class ShrinkIndexDescriptor  : RequestDescriptorBase<ShrinkIndexDescriptor,ShrinkIndexRequestParameters, IShrinkIndexRequest>, IShrinkIndexRequest
	{ 
		/// <summary>/{index}/_shrink/{target}</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="target"> this parameter is required</param>
		public ShrinkIndexDescriptor(IndexName index, IndexName target) : base(r=>r.Required("index", index).Required("target", target)){}
		// values part of the url path
		IndexName IShrinkIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		IndexName IShrinkIndexRequest.Target => Self.RouteValues.Get<IndexName>("target");

		///<summary>The name of the source index to shrink</summary>
		public ShrinkIndexDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ShrinkIndexDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

		///<summary>whether or not to copy settings from the source index (defaults to false)</summary>
		[Obsolete("Scheduled to be removed in 7.0, Elasticsearch 6.4 will throw an exception if this is turned off see elastic/elasticsearch#30404")]
		public ShrinkIndexDescriptor CopySettings(bool? copySettings = true) => Qs("copy_settings", copySettings);
		///<summary>Explicit operation timeout</summary>
		public ShrinkIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public ShrinkIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Set the number of active shards to wait for on the shrunken index before the operation returns.</summary>
		public ShrinkIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}
	///<summary>descriptor for IndicesSplit <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-split-index.html</pre></summary>
	public partial class SplitIndexDescriptor  : RequestDescriptorBase<SplitIndexDescriptor,SplitIndexRequestParameters, ISplitIndexRequest>, ISplitIndexRequest
	{ 
		/// <summary>/{index}/_split/{target}</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="target"> this parameter is required</param>
		public SplitIndexDescriptor(IndexName index, IndexName target) : base(r=>r.Required("index", index).Required("target", target)){}
		// values part of the url path
		IndexName ISplitIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		IndexName ISplitIndexRequest.Target => Self.RouteValues.Get<IndexName>("target");

		///<summary>The name of the source index to split</summary>
		public SplitIndexDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SplitIndexDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

		///<summary>whether or not to copy settings from the source index (defaults to false)</summary>
		[Obsolete("Scheduled to be removed in 7.0, Elasticsearch 6.4 will throw an exception if this is turned off see elastic/elasticsearch#30404")]
		public SplitIndexDescriptor CopySettings(bool? copySettings = true) => Qs("copy_settings", copySettings);
		///<summary>Explicit operation timeout</summary>
		public SplitIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public SplitIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Set the number of active shards to wait for on the shrunken index before the operation returns.</summary>
		public SplitIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}
	///<summary>descriptor for IndicesStatsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-stats.html</pre></summary>
	public partial class IndicesStatsDescriptor  : RequestDescriptorBase<IndicesStatsDescriptor,IndicesStatsRequestParameters, IIndicesStatsRequest>, IIndicesStatsRequest
	{ 
		/// <summary>/_stats</summary>
		public IndicesStatsDescriptor() : base(){}
		// values part of the url path
		Indices IIndicesStatsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Metrics IIndicesStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public IndicesStatsDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public IndicesStatsDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public IndicesStatsDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>Limit the information returned the specific metrics.</summary>
		public IndicesStatsDescriptor Metric(IndicesStatsMetric metric) => Assign(metric, (a,v)=>a.RouteValues.Optional("metric", (Metrics)v));

		// Request parameters

		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor CompletionFields(Fields completionFields) => Qs("completion_fields", completionFields);
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor CompletionFields<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("completion_fields", fields?.Select(e=>(Field)e));

		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor FielddataFields(Fields fielddataFields) => Qs("fielddata_fields", fielddataFields);
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor FielddataFields<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("fielddata_fields", fields?.Select(e=>(Field)e));

		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("fields", fields?.Select(e=>(Field)e));

		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public IndicesStatsDescriptor Groups(params string[] groups) => Qs("groups", groups);
		///<summary>Return stats aggregated at cluster, index or shard level</summary>
		public IndicesStatsDescriptor Level(Level? level) => Qs("level", level);
		///<summary>Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)</summary>
		public IndicesStatsDescriptor IncludeSegmentFileSizes(bool? includeSegmentFileSizes = true) => Qs("include_segment_file_sizes", includeSegmentFileSizes);
	}
	///<summary>descriptor for IndicesUpdateAliasesForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class BulkAliasDescriptor  : RequestDescriptorBase<BulkAliasDescriptor,BulkAliasRequestParameters, IBulkAliasRequest>, IBulkAliasRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Request timeout</summary>
		public BulkAliasDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public BulkAliasDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for IndicesUpgradeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html</pre></summary>
	public partial class UpgradeDescriptor  : RequestDescriptorBase<UpgradeDescriptor,UpgradeRequestParameters, IUpgradeRequest>, IUpgradeRequest
	{ 
		/// <summary>/_upgrade</summary>
		public UpgradeDescriptor() : base(){}
		// values part of the url path
		Indices IUpgradeRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public UpgradeDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UpgradeDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public UpgradeDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpgradeDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpgradeDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpgradeDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Specify whether the request should block until the all segments are upgraded (default: false)</summary>
		public UpgradeDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
		///<summary>If true, only ancient (an older Lucene major release) segments will be upgraded</summary>
		public UpgradeDescriptor OnlyAncientSegments(bool? onlyAncientSegments = true) => Qs("only_ancient_segments", onlyAncientSegments);
	}
	///<summary>descriptor for IndicesValidateQueryForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html</pre></summary>
	public partial class ValidateQueryDescriptor<T>  : RequestDescriptorBase<ValidateQueryDescriptor<T>,ValidateQueryRequestParameters, IValidateQueryRequest>, IValidateQueryRequest
	{ 
		/// <summary>/_validate/query</summary>
		public ValidateQueryDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		// values part of the url path
		Indices IValidateQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IValidateQueryRequest.Type => Self.RouteValues.Get<Types>("type");

		///<summary>A comma-separated list of index names to restrict the operation; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public ValidateQueryDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ValidateQueryDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public ValidateQueryDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</summary>
		public ValidateQueryDescriptor<T> Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public ValidateQueryDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public ValidateQueryDescriptor<T> AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>Return detailed information about the error</summary>
		public ValidateQueryDescriptor<T> Explain(bool? explain = true) => Qs("explain", explain);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ValidateQueryDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ValidateQueryDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ValidateQueryDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Query in the Lucene query string syntax</summary>
		public ValidateQueryDescriptor<T> QueryOnQueryString(string queryOnQueryString) => Qs("q", queryOnQueryString);
		///<summary>The analyzer to use for the query string</summary>
		public ValidateQueryDescriptor<T> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public ValidateQueryDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public ValidateQueryDescriptor<T> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public ValidateQueryDescriptor<T> Df(string df) => Qs("df", df);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public ValidateQueryDescriptor<T> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>Provide a more detailed explanation showing the actual Lucene query that will be executed.</summary>
		public ValidateQueryDescriptor<T> Rewrite(bool? rewrite = true) => Qs("rewrite", rewrite);
		///<summary>Execute validation on all shards instead of one random shard per index</summary>
		public ValidateQueryDescriptor<T> AllShards(bool? allShards = true) => Qs("all_shards", allShards);
	}
	///<summary>descriptor for Info <pre>http://www.elastic.co/guide/</pre></summary>
	public partial class RootNodeInfoDescriptor  : RequestDescriptorBase<RootNodeInfoDescriptor,RootNodeInfoRequestParameters, IRootNodeInfoRequest>, IRootNodeInfoRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for IngestDeletePipeline <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class DeletePipelineDescriptor  : RequestDescriptorBase<DeletePipelineDescriptor,DeletePipelineRequestParameters, IDeletePipelineRequest>, IDeletePipelineRequest
	{ 
		/// <summary>/_ingest/pipeline/{id}</summary>
		///<param name="id"> this parameter is required</param>
		public DeletePipelineDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id IDeletePipelineRequest.Id => Self.RouteValues.Get<Id>("id");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeletePipelineDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public DeletePipelineDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for IngestGetPipeline <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class GetPipelineDescriptor  : RequestDescriptorBase<GetPipelineDescriptor,GetPipelineRequestParameters, IGetPipelineRequest>, IGetPipelineRequest
	{ 
		/// <summary>/_ingest/pipeline</summary>
		public GetPipelineDescriptor() : base(){}
		// values part of the url path
		Id IGetPipelineRequest.Id => Self.RouteValues.Get<Id>("id");

		///<summary>Comma separated list of pipeline ids. Wildcards supported</summary>
		public GetPipelineDescriptor Id(Id id) => Assign(id, (a,v)=>a.RouteValues.Optional("id", v));

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetPipelineDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for IngestProcessorGrok <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class GrokProcessorPatternsDescriptor  : RequestDescriptorBase<GrokProcessorPatternsDescriptor,GrokProcessorPatternsRequestParameters, IGrokProcessorPatternsRequest>, IGrokProcessorPatternsRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for IngestPutPipeline <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class PutPipelineDescriptor  : RequestDescriptorBase<PutPipelineDescriptor,PutPipelineRequestParameters, IPutPipelineRequest>, IPutPipelineRequest
	{ 
		/// <summary>/_ingest/pipeline/{id}</summary>
		///<param name="id"> this parameter is required</param>
		public PutPipelineDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id IPutPipelineRequest.Id => Self.RouteValues.Get<Id>("id");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public PutPipelineDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public PutPipelineDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for IngestSimulate <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class SimulatePipelineDescriptor  : RequestDescriptorBase<SimulatePipelineDescriptor,SimulatePipelineRequestParameters, ISimulatePipelineRequest>, ISimulatePipelineRequest
	{ 
		/// <summary>/_ingest/pipeline/_simulate</summary>
		public SimulatePipelineDescriptor() : base(){}
		// values part of the url path
		Id ISimulatePipelineRequest.Id => Self.RouteValues.Get<Id>("id");

		///<summary>Pipeline ID</summary>
		public SimulatePipelineDescriptor Id(Id id) => Assign(id, (a,v)=>a.RouteValues.Optional("id", v));

		// Request parameters

		///<summary>Verbose mode. Display data output for each processor in executed pipeline</summary>
		public SimulatePipelineDescriptor Verbose(bool? verbose = true) => Qs("verbose", verbose);
	}
	///<summary>descriptor for Mget <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html</pre></summary>
	public partial class MultiGetDescriptor  : RequestDescriptorBase<MultiGetDescriptor,MultiGetRequestParameters, IMultiGetRequest>, IMultiGetRequest
	{ 
		/// <summary>/_mget</summary>
		public MultiGetDescriptor() : base(){}
		// values part of the url path
		IndexName IMultiGetRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IMultiGetRequest.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>The name of the index</summary>
		public MultiGetDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MultiGetDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (IndexName)v));

		///<summary>The type of the document</summary>
		public MultiGetDescriptor Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public MultiGetDescriptor Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (TypeName)v));

		// Request parameters

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public MultiGetDescriptor Preference(string preference) => Qs("preference", preference);
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public MultiGetDescriptor Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public MultiGetDescriptor Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public MultiGetDescriptor Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public MultiGetDescriptor SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public MultiGetDescriptor SourceExclude(Fields sourceExclude) => Qs("_source_excludes", sourceExclude);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public MultiGetDescriptor SourceExclude<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("_source_excludes", fields?.Select(e=>(Field)e));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public MultiGetDescriptor SourceInclude(Fields sourceInclude) => Qs("_source_includes", sourceInclude);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public MultiGetDescriptor SourceInclude<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("_source_includes", fields?.Select(e=>(Field)e));

	}
	///<summary>descriptor for Msearch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-multi-search.html</pre></summary>
	public partial class MultiSearchDescriptor  : RequestDescriptorBase<MultiSearchDescriptor,MultiSearchRequestParameters, IMultiSearchRequest>, IMultiSearchRequest
	{ 
		/// <summary>/_msearch</summary>
		public MultiSearchDescriptor(){}
		// values part of the url path
		Indices IMultiSearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IMultiSearchRequest.Type => Self.RouteValues.Get<Types>("type");

		///<summary>A comma-separated list of index names to use as default</summary>
		public MultiSearchDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MultiSearchDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public MultiSearchDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to use as default</summary>
		public MultiSearchDescriptor Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public MultiSearchDescriptor Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public MultiSearchDescriptor AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>Search operation type</summary>
		public MultiSearchDescriptor SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Controls the maximum number of concurrent searches the multi search api will execute</summary>
		public MultiSearchDescriptor MaxConcurrentSearches(long? maxConcurrentSearches) => Qs("max_concurrent_searches", maxConcurrentSearches);
		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public MultiSearchDescriptor TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
		///<summary>A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.</summary>
		public MultiSearchDescriptor PreFilterShardSize(long? preFilterShardSize) => Qs("pre_filter_shard_size", preFilterShardSize);
		///<summary>The number of concurrent shard requests each sub search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests</summary>
		public MultiSearchDescriptor MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
		///<summary>This parameter is ignored in this version. It is used in the next major version to control whether the rest response should render the total.hits as an object or a number</summary>
		public MultiSearchDescriptor TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("rest_total_hits_as_int", totalHitsAsInteger);
	}
	///<summary>descriptor for MsearchTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html</pre></summary>
	public partial class MultiSearchTemplateDescriptor  : RequestDescriptorBase<MultiSearchTemplateDescriptor,MultiSearchTemplateRequestParameters, IMultiSearchTemplateRequest>, IMultiSearchTemplateRequest
	{ 
		/// <summary>/_msearch/template</summary>
		public MultiSearchTemplateDescriptor(){}
		// values part of the url path
		Indices IMultiSearchTemplateRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IMultiSearchTemplateRequest.Type => Self.RouteValues.Get<Types>("type");

		///<summary>A comma-separated list of index names to use as default</summary>
		public MultiSearchTemplateDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MultiSearchTemplateDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public MultiSearchTemplateDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to use as default</summary>
		public MultiSearchTemplateDescriptor Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public MultiSearchTemplateDescriptor Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public MultiSearchTemplateDescriptor AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>Search operation type</summary>
		public MultiSearchTemplateDescriptor SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public MultiSearchTemplateDescriptor TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
		///<summary>Controls the maximum number of concurrent searches the multi search api will execute</summary>
		public MultiSearchTemplateDescriptor MaxConcurrentSearches(long? maxConcurrentSearches) => Qs("max_concurrent_searches", maxConcurrentSearches);
		///<summary>This parameter is ignored in this version. It is used in the next major version to control whether the rest response should render the total.hits as an object or a number</summary>
		public MultiSearchTemplateDescriptor TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("rest_total_hits_as_int", totalHitsAsInteger);
	}
	///<summary>descriptor for Mtermvectors <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html</pre></summary>
	public partial class MultiTermVectorsDescriptor  : RequestDescriptorBase<MultiTermVectorsDescriptor,MultiTermVectorsRequestParameters, IMultiTermVectorsRequest>, IMultiTermVectorsRequest
	{ 
		/// <summary>/_mtermvectors</summary>
		public MultiTermVectorsDescriptor() : base(){}
		// values part of the url path
		IndexName IMultiTermVectorsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IMultiTermVectorsRequest.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>The index in which the document resides.</summary>
		public MultiTermVectorsDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MultiTermVectorsDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (IndexName)v));

		///<summary>The type of the document.</summary>
		public MultiTermVectorsDescriptor Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public MultiTermVectorsDescriptor Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (TypeName)v));

		// Request parameters

		///<summary>Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor TermStatistics(bool? termStatistics = true) => Qs("term_statistics", termStatistics);
		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor FieldStatistics(bool? fieldStatistics = true) => Qs("field_statistics", fieldStatistics);
		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("fields", fields?.Select(e=>(Field)e));

		///<summary>Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor Offsets(bool? offsets = true) => Qs("offsets", offsets);
		///<summary>Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor Positions(bool? positions = true) => Qs("positions", positions);
		///<summary>Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor Payloads(bool? payloads = true) => Qs("payloads", payloads);
		///<summary>Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor Preference(string preference) => Qs("preference", preference);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public MultiTermVectorsDescriptor Routing(Routing routing) => Qs("routing", routing);
		///<summary>Parent id of documents. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		[Obsolete("Scheduled to be removed in 7.0, the parent parameter has been deprecated from elasticsearch, please use routing instead directly.")]
		public MultiTermVectorsDescriptor Parent(string parent) => Qs("parent", parent);
		///<summary>Specifies if requests are real-time as opposed to near-real-time (default: true).</summary>
		public MultiTermVectorsDescriptor Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Explicit version number for concurrency control</summary>
		public MultiTermVectorsDescriptor Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public MultiTermVectorsDescriptor VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}
	///<summary>descriptor for NodesHotThreadsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-hot-threads.html</pre></summary>
	public partial class NodesHotThreadsDescriptor  : RequestDescriptorBase<NodesHotThreadsDescriptor,NodesHotThreadsRequestParameters, INodesHotThreadsRequest>, INodesHotThreadsRequest
	{ 
		/// <summary>/_cluster/nodes/hotthreads</summary>
		public NodesHotThreadsDescriptor() : base(){}
		// values part of the url path
		NodeIds INodesHotThreadsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");

		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public NodesHotThreadsDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a,v)=>a.RouteValues.Optional("node_id", v));

		// Request parameters

		///<summary>The interval for the second sampling of threads</summary>
		public NodesHotThreadsDescriptor Interval(Time interval) => Qs("interval", interval);
		///<summary>Number of samples of thread stacktrace (default: 10)</summary>
		public NodesHotThreadsDescriptor Snapshots(long? snapshots) => Qs("snapshots", snapshots);
		///<summary>Specify the number of threads to provide information for (default: 3)</summary>
		public NodesHotThreadsDescriptor Threads(long? threads) => Qs("threads", threads);
		///<summary>Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)</summary>
		public NodesHotThreadsDescriptor IgnoreIdleThreads(bool? ignoreIdleThreads = true) => Qs("ignore_idle_threads", ignoreIdleThreads);
		///<summary>The type to sample (default: cpu)</summary>
		public NodesHotThreadsDescriptor ThreadType(ThreadType? threadType) => Qs("type", threadType);
		///<summary>Explicit operation timeout</summary>
		public NodesHotThreadsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for NodesInfoForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-info.html</pre></summary>
	public partial class NodesInfoDescriptor  : RequestDescriptorBase<NodesInfoDescriptor,NodesInfoRequestParameters, INodesInfoRequest>, INodesInfoRequest
	{ 
		/// <summary>/_nodes</summary>
		public NodesInfoDescriptor() : base(){}
		// values part of the url path
		NodeIds INodesInfoRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		Metrics INodesInfoRequest.Metric => Self.RouteValues.Get<Metrics>("metric");

		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public NodesInfoDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a,v)=>a.RouteValues.Optional("node_id", v));

		///<summary>A comma-separated list of metrics you wish returned. Leave empty to return all.</summary>
		public NodesInfoDescriptor Metric(NodesInfoMetric metric) => Assign(metric, (a,v)=>a.RouteValues.Optional("metric", (Metrics)v));

		// Request parameters

		///<summary>Return settings in flat format (default: false)</summary>
		public NodesInfoDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Explicit operation timeout</summary>
		public NodesInfoDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for NodesReloadSecureSettingsForAll <pre>https://www.elastic.co/guide/en/elasticsearch/reference/6.x/secure-settings.html#reloadable-secure-settings</pre></summary>
	public partial class ReloadSecureSettingsDescriptor  : RequestDescriptorBase<ReloadSecureSettingsDescriptor,ReloadSecureSettingsRequestParameters, IReloadSecureSettingsRequest>, IReloadSecureSettingsRequest
	{ 
		/// <summary>/_nodes/reload_secure_settings</summary>
		public ReloadSecureSettingsDescriptor() : base(){}
		// values part of the url path
		NodeIds IReloadSecureSettingsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");

		///<summary>A comma-separated list of node IDs to span the reload/reinit call. Should stay empty because reloading usually involves all cluster nodes.</summary>
		public ReloadSecureSettingsDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a,v)=>a.RouteValues.Optional("node_id", v));

		// Request parameters

		///<summary>Explicit operation timeout</summary>
		public ReloadSecureSettingsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for NodesStatsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-stats.html</pre></summary>
	public partial class NodesStatsDescriptor  : RequestDescriptorBase<NodesStatsDescriptor,NodesStatsRequestParameters, INodesStatsRequest>, INodesStatsRequest
	{ 
		/// <summary>/_nodes/stats</summary>
		public NodesStatsDescriptor() : base(){}
		// values part of the url path
		Metrics INodesStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		IndexMetrics INodesStatsRequest.IndexMetric => Self.RouteValues.Get<IndexMetrics>("index_metric");
		NodeIds INodesStatsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");

		///<summary>Limit the information returned to the specified metrics</summary>
		public NodesStatsDescriptor Metric(NodesStatsMetric metric) => Assign(metric, (a,v)=>a.RouteValues.Optional("metric", (Metrics)v));

		///<summary>Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.</summary>
		public NodesStatsDescriptor IndexMetric(NodesStatsIndexMetric indexMetric) => Assign(indexMetric, (a,v)=>a.RouteValues.Optional("index_metric", (IndexMetrics)v));

		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public NodesStatsDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a,v)=>a.RouteValues.Optional("node_id", v));

		// Request parameters

		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor CompletionFields(Fields completionFields) => Qs("completion_fields", completionFields);
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor CompletionFields<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("completion_fields", fields?.Select(e=>(Field)e));

		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor FielddataFields(Fields fielddataFields) => Qs("fielddata_fields", fielddataFields);
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor FielddataFields<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("fielddata_fields", fields?.Select(e=>(Field)e));

		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class => Qs("fields", fields?.Select(e=>(Field)e));

		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public NodesStatsDescriptor Groups(bool? groups = true) => Qs("groups", groups);
		///<summary>Return indices stats aggregated at index, node or shard level</summary>
		public NodesStatsDescriptor Level(Level? level) => Qs("level", level);
		///<summary>A comma-separated list of document types for the `indexing` index metric</summary>
		public NodesStatsDescriptor Types(params string[] types) => Qs("types", types);
		///<summary>Explicit operation timeout</summary>
		public NodesStatsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)</summary>
		public NodesStatsDescriptor IncludeSegmentFileSizes(bool? includeSegmentFileSizes = true) => Qs("include_segment_file_sizes", includeSegmentFileSizes);
	}
	///<summary>descriptor for NodesUsageForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-usage.html</pre></summary>
	public partial class NodesUsageDescriptor  : RequestDescriptorBase<NodesUsageDescriptor,NodesUsageRequestParameters, INodesUsageRequest>, INodesUsageRequest
	{ 
		/// <summary>/_nodes/usage</summary>
		public NodesUsageDescriptor() : base(){}
		// values part of the url path
		Metrics INodesUsageRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		NodeIds INodesUsageRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");

		///<summary>Limit the information returned to the specified metrics</summary>
		public NodesUsageDescriptor Metric(NodesUsageMetric metric) => Assign(metric, (a,v)=>a.RouteValues.Optional("metric", (Metrics)v));

		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public NodesUsageDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a,v)=>a.RouteValues.Optional("node_id", v));

		// Request parameters

		///<summary>Explicit operation timeout</summary>
		public NodesUsageDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for Ping <pre>http://www.elastic.co/guide/</pre></summary>
	public partial class PingDescriptor  : RequestDescriptorBase<PingDescriptor,PingRequestParameters, IPingRequest>, IPingRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for PutScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class PutScriptDescriptor  : RequestDescriptorBase<PutScriptDescriptor,PutScriptRequestParameters, IPutScriptRequest>, IPutScriptRequest
	{ 
		/// <summary>/_scripts/{id}</summary>
		///<param name="id"> this parameter is required</param>
		public PutScriptDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id IPutScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		Name IPutScriptRequest.Context => Self.RouteValues.Get<Name>("context");

		///<summary>Script context</summary>
		public PutScriptDescriptor Context(Name context) => Assign(context, (a,v)=>a.RouteValues.Optional("context", v));

		// Request parameters

		///<summary>Explicit operation timeout</summary>
		public PutScriptDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify timeout for connection to master</summary>
		public PutScriptDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for Reindex <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-reindex.html</pre></summary>
	public partial class ReindexOnServerDescriptor  : RequestDescriptorBase<ReindexOnServerDescriptor,ReindexOnServerRequestParameters, IReindexOnServerRequest>, IReindexOnServerRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Should the effected indexes be refreshed?</summary>
		public ReindexOnServerDescriptor Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>Time each individual bulk request should wait for shards that are unavailable.</summary>
		public ReindexOnServerDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Sets the number of shard copies that must be active before proceeding with the reindex operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public ReindexOnServerDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>Should the request should block until the reindex is complete.</summary>
		public ReindexOnServerDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
		///<summary>The throttle to set on this request in sub-requests per second. -1 means no throttle.</summary>
		public ReindexOnServerDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
		///<summary>The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.</summary>
		public ReindexOnServerDescriptor Slices(long? slices) => Qs("slices", slices);
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public ReindexOnServerDescriptor Scroll(Time scroll) => Qs("scroll", scroll);
	}
	///<summary>descriptor for ReindexRethrottle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-reindex.html</pre></summary>
	public partial class ReindexRethrottleDescriptor  : RequestDescriptorBase<ReindexRethrottleDescriptor,ReindexRethrottleRequestParameters, IReindexRethrottleRequest>, IReindexRethrottleRequest
	{ 
		/// <summary>/_reindex/{task_id}/_rethrottle</summary>
		///<param name="task_id"> this parameter is required</param>
		public ReindexRethrottleDescriptor(TaskId task_id) : base(r=>r.Required("task_id", task_id)){}
		// values part of the url path
		TaskId IReindexRethrottleRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");

		// Request parameters

		///<summary>The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.</summary>
		public ReindexRethrottleDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
	}
	///<summary>descriptor for RenderSearchTemplate <pre>http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/search-template.html</pre></summary>
	public partial class RenderSearchTemplateDescriptor  : RequestDescriptorBase<RenderSearchTemplateDescriptor,RenderSearchTemplateRequestParameters, IRenderSearchTemplateRequest>, IRenderSearchTemplateRequest
	{ 
		/// <summary>/_render/template</summary>
		public RenderSearchTemplateDescriptor() : base(){}
		// values part of the url path
		Id IRenderSearchTemplateRequest.Id => Self.RouteValues.Get<Id>("id");

		///<summary>The id of the stored search template</summary>
		public RenderSearchTemplateDescriptor Id(Id id) => Assign(id, (a,v)=>a.RouteValues.Optional("id", v));

		// Request parameters

	}
	///<summary>descriptor for ScriptsPainlessExecute <pre>https://www.elastic.co/guide/en/elasticsearch/painless/master/painless-execute-api.html</pre></summary>
	public partial class ExecutePainlessScriptDescriptor  : RequestDescriptorBase<ExecutePainlessScriptDescriptor,ExecutePainlessScriptRequestParameters, IExecutePainlessScriptRequest>, IExecutePainlessScriptRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for Scroll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html</pre></summary>
	public partial class ScrollDescriptor<T>  : RequestDescriptorBase<ScrollDescriptor<T>,ScrollRequestParameters, IScrollRequest>, IScrollRequest
	{ 
		/// <summary>/_search/scroll</summary>
		public ScrollDescriptor() : base(){}
		// values part of the url path

		// Request parameters

		///<summary>This parameter is ignored in this version. It is used in the next major version to control whether the rest response should render the total.hits as an object or a number</summary>
		public ScrollDescriptor<T> TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("rest_total_hits_as_int", totalHitsAsInteger);
	}
	///<summary>descriptor for Search <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html</pre></summary>
	public partial class SearchDescriptor<T>  : RequestDescriptorBase<SearchDescriptor<T>,SearchRequestParameters, ISearchRequest>, ISearchRequest
	{ 
		/// <summary>/_search</summary>
		public SearchDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		// values part of the url path
		Indices ISearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchRequest.Type => Self.RouteValues.Get<Types>("type");

		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public SearchDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SearchDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public SearchDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public SearchDescriptor<T> Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public SearchDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public SearchDescriptor<T> AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>The analyzer to use for the query string</summary>
		public SearchDescriptor<T> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public SearchDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public SearchDescriptor<T> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public SearchDescriptor<T> Df(string df) => Qs("df", df);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether specified concrete, expanded or aliased indices should be ignored when throttled</summary>
		public SearchDescriptor<T> IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public SearchDescriptor<T> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public SearchDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public SearchDescriptor<T> Scroll(Time scroll) => Qs("scroll", scroll);
		///<summary>Search operation type</summary>
		public SearchDescriptor<T> SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Specific 'tag' of the request for logging and statistical purposes</summary>
		public SearchDescriptor<T> Stats(params string[] stats) => Qs("stats", stats);
		///<summary>Specify which field to use for suggestions</summary>
		public SearchDescriptor<T> SuggestField(Field suggestField) => Qs("suggest_field", suggestField);
		///<summary>Specify which field to use for suggestions</summary>
		public SearchDescriptor<T> SuggestField(Expression<Func<T, object>> field)  => Qs("suggest_field", (Field)field);
		///<summary>Specify suggest mode</summary>
		public SearchDescriptor<T> SuggestMode(SuggestMode? suggestMode) => Qs("suggest_mode", suggestMode);
		///<summary>How many suggestions to return in response</summary>
		public SearchDescriptor<T> SuggestSize(long? suggestSize) => Qs("suggest_size", suggestSize);
		///<summary>The source text for which the suggestions should be returned</summary>
		public SearchDescriptor<T> SuggestText(string suggestText) => Qs("suggest_text", suggestText);
		///<summary>Indicate if the number of documents that match the query should be tracked</summary>
		public SearchDescriptor<T> TrackTotalHits(bool? trackTotalHits = true) => Qs("track_total_hits", trackTotalHits);
		///<summary>Indicate if an error should be returned if there is a partial search failure or timeout</summary>
		public SearchDescriptor<T> AllowPartialSearchResults(bool? allowPartialSearchResults = true) => Qs("allow_partial_search_results", allowPartialSearchResults);
		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public SearchDescriptor<T> TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
		///<summary>Specify whether to return sequence number and primary term of the last modification of each hit</summary>
		public SearchDescriptor<T> SeqNoPrimaryTerm(bool? seqNoPrimaryTerm = true) => Qs("seq_no_primary_term", seqNoPrimaryTerm);
		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public SearchDescriptor<T> RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
		///<summary>The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.</summary>
		public SearchDescriptor<T> BatchedReduceSize(long? batchedReduceSize) => Qs("batched_reduce_size", batchedReduceSize);
		///<summary>The number of concurrent shard requests this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests</summary>
		public SearchDescriptor<T> MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
		///<summary>A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.</summary>
		public SearchDescriptor<T> PreFilterShardSize(long? preFilterShardSize) => Qs("pre_filter_shard_size", preFilterShardSize);
		///<summary>This parameter is ignored in this version. It is used in the next major version to control whether the rest response should render the total.hits as an object or a number</summary>
		public SearchDescriptor<T> TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("rest_total_hits_as_int", totalHitsAsInteger);
	}
	///<summary>descriptor for SearchShards <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-shards.html</pre></summary>
	public partial class SearchShardsDescriptor<T>  : RequestDescriptorBase<SearchShardsDescriptor<T>,SearchShardsRequestParameters, ISearchShardsRequest>, ISearchShardsRequest
	{ 
		/// <summary>/_search_shards. Will infer the index from the generic type</summary>
		public SearchShardsDescriptor() : base(r => r.Optional("index", (Indices)typeof(T))){}
		// values part of the url path
		Indices ISearchShardsRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public SearchShardsDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SearchShardsDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public SearchShardsDescriptor<T> AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchShardsDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public SearchShardsDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public SearchShardsDescriptor<T> Local(bool? local = true) => Qs("local", local);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchShardsDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchShardsDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchShardsDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	}
	///<summary>descriptor for SearchTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</pre></summary>
	public partial class SearchTemplateDescriptor<T>  : RequestDescriptorBase<SearchTemplateDescriptor<T>,SearchTemplateRequestParameters, ISearchTemplateRequest>, ISearchTemplateRequest
	{ 
		/// <summary>/_search/template</summary>
		public SearchTemplateDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		// values part of the url path
		Indices ISearchTemplateRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchTemplateRequest.Type => Self.RouteValues.Get<Types>("type");

		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public SearchTemplateDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SearchTemplateDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public SearchTemplateDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public SearchTemplateDescriptor<T> Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public SearchTemplateDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public SearchTemplateDescriptor<T> AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchTemplateDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether specified concrete, expanded or aliased indices should be ignored when throttled</summary>
		public SearchTemplateDescriptor<T> IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchTemplateDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchTemplateDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchTemplateDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public SearchTemplateDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public SearchTemplateDescriptor<T> Scroll(Time scroll) => Qs("scroll", scroll);
		///<summary>Search operation type</summary>
		public SearchTemplateDescriptor<T> SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Specify whether to return detailed information about score computation as part of a hit</summary>
		public SearchTemplateDescriptor<T> Explain(bool? explain = true) => Qs("explain", explain);
		///<summary>Specify whether to profile the query execution</summary>
		public SearchTemplateDescriptor<T> Profile(bool? profile = true) => Qs("profile", profile);
		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public SearchTemplateDescriptor<T> TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
		///<summary>This parameter is ignored in this version. It is used in the next major version to control whether the rest response should render the total.hits as an object or a number</summary>
		public SearchTemplateDescriptor<T> TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("rest_total_hits_as_int", totalHitsAsInteger);
	}
	///<summary>descriptor for SnapshotCreate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class SnapshotDescriptor  : RequestDescriptorBase<SnapshotDescriptor,SnapshotRequestParameters, ISnapshotRequest>, ISnapshotRequest
	{ 
		/// <summary>/_snapshot/{repository}/{snapshot}</summary>
		///<param name="repository"> this parameter is required</param>
		///<param name="snapshot"> this parameter is required</param>
		public SnapshotDescriptor(Name repository, Name snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		// values part of the url path
		Name ISnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name ISnapshotRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Should this request wait until the operation has completed before returning</summary>
		public SnapshotDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}
	///<summary>descriptor for SnapshotCreateRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class CreateRepositoryDescriptor  : RequestDescriptorBase<CreateRepositoryDescriptor,CreateRepositoryRequestParameters, ICreateRepositoryRequest>, ICreateRepositoryRequest
	{ 
		/// <summary>/_snapshot/{repository}</summary>
		///<param name="repository"> this parameter is required</param>
		public CreateRepositoryDescriptor(Name repository) : base(r=>r.Required("repository", repository)){}
		// values part of the url path
		Name ICreateRepositoryRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CreateRepositoryDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public CreateRepositoryDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Whether to verify the repository after creation</summary>
		public CreateRepositoryDescriptor Verify(bool? verify = true) => Qs("verify", verify);
	}
	///<summary>descriptor for SnapshotDelete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class DeleteSnapshotDescriptor  : RequestDescriptorBase<DeleteSnapshotDescriptor,DeleteSnapshotRequestParameters, IDeleteSnapshotRequest>, IDeleteSnapshotRequest
	{ 
		/// <summary>/_snapshot/{repository}/{snapshot}</summary>
		///<param name="repository"> this parameter is required</param>
		///<param name="snapshot"> this parameter is required</param>
		public DeleteSnapshotDescriptor(Name repository, Name snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		// values part of the url path
		Name IDeleteSnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name IDeleteSnapshotRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeleteSnapshotDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for SnapshotDeleteRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class DeleteRepositoryDescriptor  : RequestDescriptorBase<DeleteRepositoryDescriptor,DeleteRepositoryRequestParameters, IDeleteRepositoryRequest>, IDeleteRepositoryRequest
	{ 
		/// <summary>/_snapshot/{repository}</summary>
		///<param name="repository"> this parameter is required</param>
		public DeleteRepositoryDescriptor(Names repository) : base(r=>r.Required("repository", repository)){}
		// values part of the url path
		Names IDeleteRepositoryRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeleteRepositoryDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public DeleteRepositoryDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for SnapshotGet <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class GetSnapshotDescriptor  : RequestDescriptorBase<GetSnapshotDescriptor,GetSnapshotRequestParameters, IGetSnapshotRequest>, IGetSnapshotRequest
	{ 
		/// <summary>/_snapshot/{repository}/{snapshot}</summary>
		///<param name="repository"> this parameter is required</param>
		///<param name="snapshot"> this parameter is required</param>
		public GetSnapshotDescriptor(Name repository, Names snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		// values part of the url path
		Name IGetSnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Names IGetSnapshotRequest.Snapshot => Self.RouteValues.Get<Names>("snapshot");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetSnapshotDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown</summary>
		public GetSnapshotDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to show verbose snapshot info or only show the basic info found in the repository index blob</summary>
		public GetSnapshotDescriptor Verbose(bool? verbose = true) => Qs("verbose", verbose);
	}
	///<summary>descriptor for SnapshotGetRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class GetRepositoryDescriptor  : RequestDescriptorBase<GetRepositoryDescriptor,GetRepositoryRequestParameters, IGetRepositoryRequest>, IGetRepositoryRequest
	{ 
		/// <summary>/_snapshot</summary>
		public GetRepositoryDescriptor() : base(){}
		// values part of the url path
		Names IGetRepositoryRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");

		///<summary>A comma-separated list of repository names</summary>
		public GetRepositoryDescriptor RepositoryName(Names repository) => Assign(repository, (a,v)=>a.RouteValues.Optional("repository", v));

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetRepositoryDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetRepositoryDescriptor Local(bool? local = true) => Qs("local", local);
	}
	///<summary>descriptor for SnapshotRestore <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class RestoreDescriptor  : RequestDescriptorBase<RestoreDescriptor,RestoreRequestParameters, IRestoreRequest>, IRestoreRequest
	{ 
		/// <summary>/_snapshot/{repository}/{snapshot}/_restore</summary>
		///<param name="repository"> this parameter is required</param>
		///<param name="snapshot"> this parameter is required</param>
		public RestoreDescriptor(Name repository, Name snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		// values part of the url path
		Name IRestoreRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name IRestoreRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public RestoreDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Should this request wait until the operation has completed before returning</summary>
		public RestoreDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}
	///<summary>descriptor for SnapshotStatus <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class SnapshotStatusDescriptor  : RequestDescriptorBase<SnapshotStatusDescriptor,SnapshotStatusRequestParameters, ISnapshotStatusRequest>, ISnapshotStatusRequest
	{ 
		/// <summary>/_snapshot/_status</summary>
		public SnapshotStatusDescriptor() : base(){}
		// values part of the url path
		Name ISnapshotStatusRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Names ISnapshotStatusRequest.Snapshot => Self.RouteValues.Get<Names>("snapshot");

		///<summary>A repository name</summary>
		public SnapshotStatusDescriptor RepositoryName(Name repository) => Assign(repository, (a,v)=>a.RouteValues.Optional("repository", v));

		///<summary>A comma-separated list of snapshot names</summary>
		public SnapshotStatusDescriptor Snapshot(Names snapshot) => Assign(snapshot, (a,v)=>a.RouteValues.Optional("snapshot", v));

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotStatusDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown</summary>
		public SnapshotStatusDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	}
	///<summary>descriptor for SnapshotVerifyRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class VerifyRepositoryDescriptor  : RequestDescriptorBase<VerifyRepositoryDescriptor,VerifyRepositoryRequestParameters, IVerifyRepositoryRequest>, IVerifyRepositoryRequest
	{ 
		/// <summary>/_snapshot/{repository}/_verify</summary>
		///<param name="repository"> this parameter is required</param>
		public VerifyRepositoryDescriptor(Name repository) : base(r=>r.Required("repository", repository)){}
		// values part of the url path
		Name IVerifyRepositoryRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public VerifyRepositoryDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public VerifyRepositoryDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for TasksCancel <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class CancelTasksDescriptor  : RequestDescriptorBase<CancelTasksDescriptor,CancelTasksRequestParameters, ICancelTasksRequest>, ICancelTasksRequest
	{ 
		/// <summary>/_tasks/_cancel</summary>
		public CancelTasksDescriptor() : base(){}
		// values part of the url path
		TaskId ICancelTasksRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");

		///<summary>Cancel the task with specified task id (node_id:task_number)</summary>
		public CancelTasksDescriptor TaskId(TaskId taskId) => Assign(taskId, (a,v)=>a.RouteValues.Optional("task_id", v));

		// Request parameters

		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public CancelTasksDescriptor Nodes(params string[] nodes) => Qs("nodes", nodes);
		///<summary>A comma-separated list of actions that should be cancelled. Leave empty to cancel all.</summary>
		public CancelTasksDescriptor Actions(params string[] actions) => Qs("actions", actions);
		///<summary>Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.</summary>
		public CancelTasksDescriptor ParentTaskId(string parentTaskId) => Qs("parent_task_id", parentTaskId);
		///<summary>Cancel tasks with specified parent node.</summary>
		[Obsolete("Scheduled to be removed in 7.0, Removed in 6.3.0 from the server see https://github.com/elastic/elasticsearch/pull/28841")]
		public CancelTasksDescriptor ParentNode(string parentNode) => Qs("parent_node", parentNode);
	}
	///<summary>descriptor for TasksGet <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class GetTaskDescriptor  : RequestDescriptorBase<GetTaskDescriptor,GetTaskRequestParameters, IGetTaskRequest>, IGetTaskRequest
	{ 
		/// <summary>/_tasks/{task_id}</summary>
		///<param name="task_id"> this parameter is required</param>
		public GetTaskDescriptor(TaskId task_id) : base(r=>r.Required("task_id", task_id)){}
		// values part of the url path
		TaskId IGetTaskRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");

		// Request parameters

		///<summary>Wait for the matching tasks to complete (default: false)</summary>
		public GetTaskDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
		///<summary>Explicit operation timeout</summary>
		public GetTaskDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for TasksList <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class ListTasksDescriptor  : RequestDescriptorBase<ListTasksDescriptor,ListTasksRequestParameters, IListTasksRequest>, IListTasksRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public ListTasksDescriptor Nodes(params string[] nodes) => Qs("nodes", nodes);
		///<summary>A comma-separated list of actions that should be returned. Leave empty to return all.</summary>
		public ListTasksDescriptor Actions(params string[] actions) => Qs("actions", actions);
		///<summary>Return detailed task information (default: false)</summary>
		public ListTasksDescriptor Detailed(bool? detailed = true) => Qs("detailed", detailed);
		///<summary>Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.</summary>
		public ListTasksDescriptor ParentTaskId(string parentTaskId) => Qs("parent_task_id", parentTaskId);
		///<summary>Wait for the matching tasks to complete (default: false)</summary>
		public ListTasksDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
		///<summary>Group tasks by nodes or parent/child relationships</summary>
		public ListTasksDescriptor GroupBy(GroupBy? groupBy) => Qs("group_by", groupBy);
		///<summary>Explicit operation timeout</summary>
		public ListTasksDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Return tasks with the specified parent node</summary>
		[Obsolete("Scheduled to be removed in 7.0, Removed in 6.3.0 from the server see https://github.com/elastic/elasticsearch/pull/28841")]
		public ListTasksDescriptor ParentNode(string parentNode) => Qs("parent_node", parentNode);
	}
	///<summary>descriptor for Termvectors <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html</pre></summary>
	public partial class TermVectorsDescriptor<TDocument>  : RequestDescriptorBase<TermVectorsDescriptor<TDocument>,TermVectorsRequestParameters, ITermVectorsRequest<TDocument>>, ITermVectorsRequest<TDocument>
	{ 
		/// <summary>/{index}/{type}/_termvectors</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="type"> this parameter is required</param>
		public TermVectorsDescriptor(IndexName index, TypeName type) : base(r=>r.Required("index", index).Required("type", type))
		=> Q("routing", new Routing(() => AutoRouteDocument()));
		/// <summary>/{index}/{type}/_termvectors</summary>
		///<param name="document"> describes an elasticsearch document of type <typeparamref name="TDocument"/> from which the index, type and id can be inferred</param>
		public TermVectorsDescriptor(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id))
		{ this.DocumentFromPath(document.Document); Q("routing", new Routing(() => AutoRouteDocument() ?? document.Document));}
		partial void DocumentFromPath(TDocument document);
		// values part of the url path
		IndexName ITermVectorsRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName ITermVectorsRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");
		Id ITermVectorsRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");

		///<summary>The index in which the document resides.</summary>
		public TermVectorsDescriptor<TDocument> Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public TermVectorsDescriptor<TDocument> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		///<summary>The type of the document.</summary>
		public TermVectorsDescriptor<TDocument> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Required("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public TermVectorsDescriptor<TDocument> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("type", (TypeName)v));

		///<summary>The id of the document, when not specified a doc param should be supplied.</summary>
		public TermVectorsDescriptor<TDocument> Id(Id id) => Assign(id, (a,v)=>a.RouteValues.Optional("id", v));

		// Request parameters

		///<summary>Specifies if total term frequency and document frequency should be returned.</summary>
		public TermVectorsDescriptor<TDocument> TermStatistics(bool? termStatistics = true) => Qs("term_statistics", termStatistics);
		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.</summary>
		public TermVectorsDescriptor<TDocument> FieldStatistics(bool? fieldStatistics = true) => Qs("field_statistics", fieldStatistics);
		///<summary>A comma-separated list of fields to return.</summary>
		public TermVectorsDescriptor<TDocument> Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of fields to return.</summary>
		public TermVectorsDescriptor<TDocument> Fields(params Expression<Func<TDocument, object>>[] fields)  => Qs("fields", fields?.Select(e=>(Field)e));

		///<summary>Specifies if term offsets should be returned.</summary>
		public TermVectorsDescriptor<TDocument> Offsets(bool? offsets = true) => Qs("offsets", offsets);
		///<summary>Specifies if term positions should be returned.</summary>
		public TermVectorsDescriptor<TDocument> Positions(bool? positions = true) => Qs("positions", positions);
		///<summary>Specifies if term payloads should be returned.</summary>
		public TermVectorsDescriptor<TDocument> Payloads(bool? payloads = true) => Qs("payloads", payloads);
		///<summary>Specify the node or shard the operation should be performed on (default: random).</summary>
		public TermVectorsDescriptor<TDocument> Preference(string preference) => Qs("preference", preference);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public TermVectorsDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Parent id of documents.</summary>
		[Obsolete("Scheduled to be removed in 7.0, the parent parameter has been deprecated from elasticsearch, please use routing instead directly.")]
		public TermVectorsDescriptor<TDocument> Parent(string parent) => Qs("parent", parent);
		///<summary>Specifies if request is real-time as opposed to near-real-time (default: true).</summary>
		public TermVectorsDescriptor<TDocument> Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Explicit version number for concurrency control</summary>
		public TermVectorsDescriptor<TDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public TermVectorsDescriptor<TDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}
	///<summary>descriptor for Update <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update.html</pre></summary>
	public partial class UpdateDescriptor<TDocument, TPartialDocument>  : RequestDescriptorBase<UpdateDescriptor<TDocument, TPartialDocument>,UpdateRequestParameters, IUpdateRequest<TDocument, TPartialDocument>>, IUpdateRequest<TDocument, TPartialDocument>
	{ 
		/// <summary>/{index}/{type}/{id}/_update</summary>
		///<param name="index"> this parameter is required</param>
		///<param name="type"> this parameter is required</param>
		///<param name="id"> this parameter is required</param>
		public UpdateDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id))
		=> Q("routing", new Routing(() => AutoRouteDocument()));
		/// <summary>/{index}/{type}/{id}/_update</summary>
		///<param name="document"> describes an elasticsearch document of type <typeparamref name="TDocument"/> from which the index, type and id can be inferred</param>
		public UpdateDescriptor(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id))
		{ this.DocumentFromPath(document.Document); Q("routing", new Routing(() => AutoRouteDocument() ?? document.Document));}
		partial void DocumentFromPath(TDocument document);
		// values part of the url path
		Id IUpdateRequest<TDocument, TPartialDocument>.Id => Self.RouteValues.Get<Id>("id");
		IndexName IUpdateRequest<TDocument, TPartialDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IUpdateRequest<TDocument, TPartialDocument>.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>The name of the index</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		///<summary>The type of the document</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Required("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("type", (TypeName)v));

		// Request parameters

		///<summary>Sets the number of shard copies that must be active before proceeding with the update operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>Whether the _source should be included in the response.</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>The script language (default: painless)</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Lang(string lang) => Qs("lang", lang);
		///<summary>ID of the parent document. Is is only used for routing and when for the upsert request</summary>
		[Obsolete("Scheduled to be removed in 7.0, the parent parameter has been deprecated from elasticsearch, please use routing instead directly.")]
		public UpdateDescriptor<TDocument, TPartialDocument> Parent(string parent) => Qs("parent", parent);
		///<summary>If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Refresh(Refresh? refresh) => Qs("refresh", refresh);
		///<summary>Specify how many times should the operation be retried when a conflict occurs (default: 0)</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> RetryOnConflict(long? retryOnConflict) => Qs("retry_on_conflict", retryOnConflict);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Explicit operation timeout</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>only perform the update operation if the last operation that has changed the document has the specified sequence number</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> IfSeqNo(long? ifSeqNo) => Qs("if_seq_no", ifSeqNo);
		///<summary>only perform the update operation if the last operation that has changed the document has the specified primary term</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> IfPrimaryTerm(long? ifPrimaryTerm) => Qs("if_primary_term", ifPrimaryTerm);
		///<summary>Explicit version number for concurrency control</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}
	///<summary>descriptor for UpdateByQuery <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update-by-query.html</pre></summary>
	public partial class UpdateByQueryDescriptor<T>  : RequestDescriptorBase<UpdateByQueryDescriptor<T>,UpdateByQueryRequestParameters, IUpdateByQueryRequest>, IUpdateByQueryRequest
	{ 
		/// <summary>/{index}/_update_by_query</summary>
		///<param name="index"> this parameter is required</param>
		public UpdateByQueryDescriptor(Indices index) : base(r=>r.Required("index", index).Required("type", (Types)typeof(T))){}
		// values part of the url path
		Indices IUpdateByQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IUpdateByQueryRequest.Type => Self.RouteValues.Get<Types>("type");

		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public UpdateByQueryDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UpdateByQueryDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public UpdateByQueryDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public UpdateByQueryDescriptor<T> Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public UpdateByQueryDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public UpdateByQueryDescriptor<T> AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>The analyzer to use for the query string</summary>
		public UpdateByQueryDescriptor<T> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public UpdateByQueryDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public UpdateByQueryDescriptor<T> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public UpdateByQueryDescriptor<T> Df(string df) => Qs("df", df);
		///<summary>Starting offset (default: 0)</summary>
		public UpdateByQueryDescriptor<T> From(long? from) => Qs("from", from);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpdateByQueryDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpdateByQueryDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>What to do when the update by query hits version conflicts?</summary>
		public UpdateByQueryDescriptor<T> Conflicts(Conflicts? conflicts) => Qs("conflicts", conflicts);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpdateByQueryDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public UpdateByQueryDescriptor<T> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>Ingest pipeline to set on index requests made by this action. (default: none)</summary>
		public UpdateByQueryDescriptor<T> Pipeline(string pipeline) => Qs("pipeline", pipeline);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public UpdateByQueryDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>Query in the Lucene query string syntax</summary>
		public UpdateByQueryDescriptor<T> QueryOnQueryString(string queryOnQueryString) => Qs("q", queryOnQueryString);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public UpdateByQueryDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public UpdateByQueryDescriptor<T> Scroll(Time scroll) => Qs("scroll", scroll);
		///<summary>Search operation type</summary>
		public UpdateByQueryDescriptor<T> SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Explicit timeout for each search request. Defaults to no timeout.</summary>
		public UpdateByQueryDescriptor<T> SearchTimeout(Time searchTimeout) => Qs("search_timeout", searchTimeout);
		///<summary>Number of hits to return (default: 10)</summary>
		public UpdateByQueryDescriptor<T> Size(long? size) => Qs("size", size);
		///<summary>A comma-separated list of <field>:<direction> pairs</summary>
		public UpdateByQueryDescriptor<T> Sort(params string[] sort) => Qs("sort", sort);
		///<summary>Whether the _source should be included in the response.</summary>
		public UpdateByQueryDescriptor<T> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public UpdateByQueryDescriptor<T> SourceExclude(Fields sourceExclude) => Qs("_source_excludes", sourceExclude);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public UpdateByQueryDescriptor<T> SourceExclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_excludes", fields?.Select(e=>(Field)e));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public UpdateByQueryDescriptor<T> SourceInclude(Fields sourceInclude) => Qs("_source_includes", sourceInclude);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public UpdateByQueryDescriptor<T> SourceInclude(params Expression<Func<T, object>>[] fields)  => Qs("_source_includes", fields?.Select(e=>(Field)e));

		///<summary>The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.</summary>
		public UpdateByQueryDescriptor<T> TerminateAfter(long? terminateAfter) => Qs("terminate_after", terminateAfter);
		///<summary>Specific 'tag' of the request for logging and statistical purposes</summary>
		public UpdateByQueryDescriptor<T> Stats(params string[] stats) => Qs("stats", stats);
		///<summary>Specify whether to return document version as part of a hit</summary>
		public UpdateByQueryDescriptor<T> Version(bool? version = true) => Qs("version", version);
		///<summary>Should the document increment the version number (internal) on hit or not (reindex)</summary>
		public UpdateByQueryDescriptor<T> VersionType(bool? versionType = true) => Qs("version_type", versionType);
		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public UpdateByQueryDescriptor<T> RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
		///<summary>Should the effected indexes be refreshed?</summary>
		public UpdateByQueryDescriptor<T> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>Time each individual bulk request should wait for shards that are unavailable.</summary>
		public UpdateByQueryDescriptor<T> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Sets the number of shard copies that must be active before proceeding with the update by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public UpdateByQueryDescriptor<T> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>Size on the scroll request powering the update by query</summary>
		public UpdateByQueryDescriptor<T> ScrollSize(long? scrollSize) => Qs("scroll_size", scrollSize);
		///<summary>Should the request should block until the update by query operation is complete.</summary>
		public UpdateByQueryDescriptor<T> WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
		///<summary>The throttle to set on this request in sub-requests per second. -1 means no throttle.</summary>
		public UpdateByQueryDescriptor<T> RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
		///<summary>The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.</summary>
		public UpdateByQueryDescriptor<T> Slices(long? slices) => Qs("slices", slices);
	}
	///<summary>descriptor for UpdateByQueryRethrottle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html</pre></summary>
	public partial class UpdateByQueryRethrottleDescriptor  : RequestDescriptorBase<UpdateByQueryRethrottleDescriptor,UpdateByQueryRethrottleRequestParameters, IUpdateByQueryRethrottleRequest>, IUpdateByQueryRethrottleRequest
	{ 
		/// <summary>/_update_by_query/{task_id}/_rethrottle</summary>
		///<param name="task_id"> this parameter is required</param>
		public UpdateByQueryRethrottleDescriptor(TaskId task_id) : base(r=>r.Required("task_id", task_id)){}
		// values part of the url path
		TaskId IUpdateByQueryRethrottleRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");

		// Request parameters

		///<summary>The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.</summary>
		public UpdateByQueryRethrottleDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
	}
	///<summary>descriptor for CcrDeleteAutoFollowPattern <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-delete-auto-follow-pattern.html</pre></summary>
	public partial class DeleteAutoFollowPatternDescriptor  : RequestDescriptorBase<DeleteAutoFollowPatternDescriptor,DeleteAutoFollowPatternRequestParameters, IDeleteAutoFollowPatternRequest>, IDeleteAutoFollowPatternRequest
	{ 
		/// <summary>/_ccr/auto_follow/{name}</summary>
		///<param name="name"> this parameter is required</param>
		public DeleteAutoFollowPatternDescriptor(Name name) : base(r=>r.Required("name", name)){}
		// values part of the url path
		Name IDeleteAutoFollowPatternRequest.Name => Self.RouteValues.Get<Name>("name");

		// Request parameters

	}
	///<summary>descriptor for CcrFollow <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-put-follow.html</pre></summary>
	public partial class CreateFollowIndexDescriptor  : RequestDescriptorBase<CreateFollowIndexDescriptor,CreateFollowIndexRequestParameters, ICreateFollowIndexRequest>, ICreateFollowIndexRequest
	{ 
		/// <summary>/{index}/_ccr/follow</summary>
		///<param name="index"> this parameter is required</param>
		public CreateFollowIndexDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		IndexName ICreateFollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The name of the follower index</summary>
		public CreateFollowIndexDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CreateFollowIndexDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

		///<summary>Sets the number of shard copies that must be active before returning. Defaults to 0. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public CreateFollowIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}
	///<summary>descriptor for CcrFollowStats <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-get-follow-stats.html</pre></summary>
	public partial class FollowIndexStatsDescriptor  : RequestDescriptorBase<FollowIndexStatsDescriptor,FollowIndexStatsRequestParameters, IFollowIndexStatsRequest>, IFollowIndexStatsRequest
	{ 
		/// <summary>/{index}/_ccr/stats</summary>
		public FollowIndexStatsDescriptor() : base(){}
		// values part of the url path
		Indices IFollowIndexStatsRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index patterns; use `_all` to perform the operation on all indices</summary>
		public FollowIndexStatsDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public FollowIndexStatsDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public FollowIndexStatsDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

	}
	///<summary>descriptor for CcrGetAutoFollowPattern <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-get-auto-follow-pattern.html</pre></summary>
	public partial class GetAutoFollowPatternDescriptor  : RequestDescriptorBase<GetAutoFollowPatternDescriptor,GetAutoFollowPatternRequestParameters, IGetAutoFollowPatternRequest>, IGetAutoFollowPatternRequest
	{ 
		/// <summary>/_ccr/auto_follow</summary>
		public GetAutoFollowPatternDescriptor() : base(){}
		// values part of the url path
		Name IGetAutoFollowPatternRequest.Name => Self.RouteValues.Get<Name>("name");

		///<summary>The name of the auto follow pattern.</summary>
		public GetAutoFollowPatternDescriptor Name(Name name) => Assign(name, (a,v)=>a.RouteValues.Optional("name", v));

		// Request parameters

	}
	///<summary>descriptor for CcrPauseFollow <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-post-pause-follow.html</pre></summary>
	public partial class PauseFollowIndexDescriptor  : RequestDescriptorBase<PauseFollowIndexDescriptor,PauseFollowIndexRequestParameters, IPauseFollowIndexRequest>, IPauseFollowIndexRequest
	{ 
		/// <summary>/{index}/_ccr/pause_follow</summary>
		///<param name="index"> this parameter is required</param>
		public PauseFollowIndexDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		IndexName IPauseFollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The name of the follower index that should pause following its leader index.</summary>
		public PauseFollowIndexDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public PauseFollowIndexDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

	}
	///<summary>descriptor for CcrPutAutoFollowPattern <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-put-auto-follow-pattern.html</pre></summary>
	public partial class CreateAutoFollowPatternDescriptor  : RequestDescriptorBase<CreateAutoFollowPatternDescriptor,CreateAutoFollowPatternRequestParameters, ICreateAutoFollowPatternRequest>, ICreateAutoFollowPatternRequest
	{ 
		/// <summary>/_ccr/auto_follow/{name}</summary>
		///<param name="name"> this parameter is required</param>
		public CreateAutoFollowPatternDescriptor(Name name) : base(r=>r.Required("name", name)){}
		// values part of the url path
		Name ICreateAutoFollowPatternRequest.Name => Self.RouteValues.Get<Name>("name");

		// Request parameters

	}
	///<summary>descriptor for CcrResumeFollow <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-post-resume-follow.html</pre></summary>
	public partial class ResumeFollowIndexDescriptor  : RequestDescriptorBase<ResumeFollowIndexDescriptor,ResumeFollowIndexRequestParameters, IResumeFollowIndexRequest>, IResumeFollowIndexRequest
	{ 
		/// <summary>/{index}/_ccr/resume_follow</summary>
		///<param name="index"> this parameter is required</param>
		public ResumeFollowIndexDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		IndexName IResumeFollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The name of the follow index to resume following.</summary>
		public ResumeFollowIndexDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ResumeFollowIndexDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

	}
	///<summary>descriptor for CcrStats <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-get-stats.html</pre></summary>
	public partial class CcrStatsDescriptor  : RequestDescriptorBase<CcrStatsDescriptor,CcrStatsRequestParameters, ICcrStatsRequest>, ICcrStatsRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for CcrUnfollow <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current</pre></summary>
	public partial class UnfollowIndexDescriptor  : RequestDescriptorBase<UnfollowIndexDescriptor,UnfollowIndexRequestParameters, IUnfollowIndexRequest>, IUnfollowIndexRequest
	{ 
		/// <summary>/{index}/_ccr/unfollow</summary>
		///<param name="index"> this parameter is required</param>
		public UnfollowIndexDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		IndexName IUnfollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The name of the follower index that should be turned into a regular index.</summary>
		public UnfollowIndexDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UnfollowIndexDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

	}
	///<summary>descriptor for XpackGraphExplore <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/graph-explore-api.html</pre></summary>
	public partial class GraphExploreDescriptor<T>  : RequestDescriptorBase<GraphExploreDescriptor<T>,GraphExploreRequestParameters, IGraphExploreRequest>, IGraphExploreRequest
	{ 
		/// <summary>/{index}/_xpack/graph/_explore</summary>
		///<param name="index"> this parameter is required</param>
		public GraphExploreDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		Indices IGraphExploreRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IGraphExploreRequest.Type => Self.RouteValues.Get<Types>("type");

		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public GraphExploreDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GraphExploreDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GraphExploreDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public GraphExploreDescriptor<T> Type(Types type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public GraphExploreDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (Types)v));

		///<summary>a shortcut into calling Type(Types.All)</summary>
		public GraphExploreDescriptor<T> AllTypes() => this.Type(Types.All);

		// Request parameters

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref="Nest6.JoinField" /> or a routing mapping on for its type exists on <see cref="Nest6.ConnectionSettings" /></para> 
		///</summary>
		public GraphExploreDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Explicit operation timeout</summary>
		public GraphExploreDescriptor<T> Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackIlmDeleteLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-delete-lifecycle.html</pre></summary>
	public partial class DeleteLifecycleDescriptor  : RequestDescriptorBase<DeleteLifecycleDescriptor,DeleteLifecycleRequestParameters, IDeleteLifecycleRequest>, IDeleteLifecycleRequest
	{ 
		/// <summary>/_ilm/policy/{policy_id}</summary>
		///<param name="policy_id"> this parameter is required</param>
		public DeleteLifecycleDescriptor(PolicyId policy_id) : base(r=>r.Required("policy_id", policy_id)){}
		// values part of the url path
		PolicyId IDeleteLifecycleRequest.PolicyId => Self.RouteValues.Get<PolicyId>("policy_id");

		// Request parameters

		///<summary>Specifies the period of time to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public DeleteLifecycleDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Specifies the period of time to wait for a response. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public DeleteLifecycleDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackIlmExplainLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-explain-lifecycle.html</pre></summary>
	public partial class ExplainLifecycleDescriptor  : RequestDescriptorBase<ExplainLifecycleDescriptor,ExplainLifecycleRequestParameters, IExplainLifecycleRequest>, IExplainLifecycleRequest
	{ 
		/// <summary>/{index}/_ilm/explain</summary>
		///<param name="index"> this parameter is required</param>
		public ExplainLifecycleDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		IndexName IExplainLifecycleRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The name of the index to explain</summary>
		public ExplainLifecycleDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ExplainLifecycleDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

		///<summary>Specifies the period of time to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public ExplainLifecycleDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Specifies the period of time to wait for a response. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public ExplainLifecycleDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackIlmGetLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-get-lifecycle.html</pre></summary>
	public partial class GetLifecycleDescriptor  : RequestDescriptorBase<GetLifecycleDescriptor,GetLifecycleRequestParameters, IGetLifecycleRequest>, IGetLifecycleRequest
	{ 
		/// <summary>/_ilm/policy/{policy_id}</summary>
		public GetLifecycleDescriptor() : base(){}
		// values part of the url path
		PolicyId IGetLifecycleRequest.PolicyId => Self.RouteValues.Get<PolicyId>("policy_id");

		///<summary>The name of the index lifecycle policy</summary>
		public GetLifecycleDescriptor PolicyId(PolicyId policyId) => Assign(policyId, (a,v)=>a.RouteValues.Optional("policy_id", v));

		// Request parameters

		///<summary>Specifies the period of time to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public GetLifecycleDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Specifies the period of time to wait for a response. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public GetLifecycleDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackIlmGetStatus <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-get-status.html</pre></summary>
	public partial class GetIlmStatusDescriptor  : RequestDescriptorBase<GetIlmStatusDescriptor,GetIlmStatusRequestParameters, IGetIlmStatusRequest>, IGetIlmStatusRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Specifies the period of time to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public GetIlmStatusDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Specifies the period of time to wait for a response. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public GetIlmStatusDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackIlmMoveToStep <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-move-to-step.html</pre></summary>
	public partial class MoveToStepDescriptor  : RequestDescriptorBase<MoveToStepDescriptor,MoveToStepRequestParameters, IMoveToStepRequest>, IMoveToStepRequest
	{ 
		/// <summary>/_ilm/move/{index}</summary>
		///<param name="index"> this parameter is required</param>
		public MoveToStepDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		IndexName IMoveToStepRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The name of the index whose lifecycle step is to change</summary>
		public MoveToStepDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MoveToStepDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

		///<summary>Specifies the period of time to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public MoveToStepDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Specifies the period of time to wait for a response. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public MoveToStepDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		//TODO THIS METHOD IS UNMAPPED!
		
	}
	///<summary>descriptor for XpackIlmPutLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-put-lifecycle.html</pre></summary>
	public partial class PutLifecycleDescriptor  : RequestDescriptorBase<PutLifecycleDescriptor,PutLifecycleRequestParameters, IPutLifecycleRequest>, IPutLifecycleRequest
	{ 
		/// <summary>/_ilm/policy/{policy_id}</summary>
		///<param name="policy_id"> this parameter is required</param>
		public PutLifecycleDescriptor(PolicyId policy_id) : base(r=>r.Required("policy_id", policy_id)){}
		// values part of the url path
		PolicyId IPutLifecycleRequest.PolicyId => Self.RouteValues.Get<PolicyId>("policy_id");

		// Request parameters

		///<summary>Specifies the period of time to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public PutLifecycleDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Specifies the period of time to wait for a response. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public PutLifecycleDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackIlmRemovePolicy <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-remove-policy.html</pre></summary>
	public partial class RemovePolicyDescriptor  : RequestDescriptorBase<RemovePolicyDescriptor,RemovePolicyRequestParameters, IRemovePolicyRequest>, IRemovePolicyRequest
	{ 
		/// <summary>/{index}/_ilm/remove</summary>
		///<param name="index"> this parameter is required</param>
		public RemovePolicyDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		IndexName IRemovePolicyRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The name of the index to remove policy on</summary>
		public RemovePolicyDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public RemovePolicyDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

		///<summary>Specifies the period of time to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public RemovePolicyDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Specifies the period of time to wait for a response. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public RemovePolicyDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackIlmRetry <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-retry-policy.html</pre></summary>
	public partial class RetryIlmDescriptor  : RequestDescriptorBase<RetryIlmDescriptor,RetryIlmRequestParameters, IRetryIlmRequest>, IRetryIlmRequest
	{ 
		/// <summary>/{index}/_ilm/retry</summary>
		///<param name="index"> this parameter is required</param>
		public RetryIlmDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		IndexName IRetryIlmRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The name of the indices (comma-separated) whose failed lifecycle step is to be retry</summary>
		public RetryIlmDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public RetryIlmDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

		///<summary>Specifies the period of time to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public RetryIlmDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Specifies the period of time to wait for a response. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public RetryIlmDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackIlmStart <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-start.html</pre></summary>
	public partial class StartIlmDescriptor  : RequestDescriptorBase<StartIlmDescriptor,StartIlmRequestParameters, IStartIlmRequest>, IStartIlmRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Specifies the period of time to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public StartIlmDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Specifies the period of time to wait for a response. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public StartIlmDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackIlmStop <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-stop.html</pre></summary>
	public partial class StopIlmDescriptor  : RequestDescriptorBase<StopIlmDescriptor,StopIlmRequestParameters, IStopIlmRequest>, IStopIlmRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Specifies the period of time to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public StopIlmDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Specifies the period of time to wait for a response. If no response is received before the timeout expires, the request fails and returns an error. Defaults to 30s.</summary>
		public StopIlmDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackInfo <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/info-api.html</pre></summary>
	public partial class XPackInfoDescriptor  : RequestDescriptorBase<XPackInfoDescriptor,XPackInfoRequestParameters, IXPackInfoRequest>, IXPackInfoRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Comma-separated list of info categories. Can be any of: build, license, features</summary>
		public XPackInfoDescriptor Categories(params string[] categories) => Qs("categories", categories);
	}
	///<summary>descriptor for XpackUsage <pre>Retrieve information about xpack features usage</pre></summary>
	public partial class XPackUsageDescriptor  : RequestDescriptorBase<XPackUsageDescriptor,XPackUsageRequestParameters, IXPackUsageRequest>, IXPackUsageRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Specify timeout for watch write operation</summary>
		public XPackUsageDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for XpackLicenseDelete <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class DeleteLicenseDescriptor  : RequestDescriptorBase<DeleteLicenseDescriptor,DeleteLicenseRequestParameters, IDeleteLicenseRequest>, IDeleteLicenseRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackLicenseGet <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class GetLicenseDescriptor  : RequestDescriptorBase<GetLicenseDescriptor,GetLicenseRequestParameters, IGetLicenseRequest>, IGetLicenseRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetLicenseDescriptor Local(bool? local = true) => Qs("local", local);
	}
	///<summary>descriptor for XpackLicenseGetBasicStatus <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class GetBasicLicenseStatusDescriptor  : RequestDescriptorBase<GetBasicLicenseStatusDescriptor,GetBasicLicenseStatusRequestParameters, IGetBasicLicenseStatusRequest>, IGetBasicLicenseStatusRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackLicenseGetTrialStatus <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class GetTrialLicenseStatusDescriptor  : RequestDescriptorBase<GetTrialLicenseStatusDescriptor,GetTrialLicenseStatusRequestParameters, IGetTrialLicenseStatusRequest>, IGetTrialLicenseStatusRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackLicensePost <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class PostLicenseDescriptor  : RequestDescriptorBase<PostLicenseDescriptor,PostLicenseRequestParameters, IPostLicenseRequest>, IPostLicenseRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>whether the user has acknowledged acknowledge messages (default: false)</summary>
		public PostLicenseDescriptor Acknowledge(bool? acknowledge = true) => Qs("acknowledge", acknowledge);
	}
	///<summary>descriptor for XpackLicensePostStartBasic <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class StartBasicLicenseDescriptor  : RequestDescriptorBase<StartBasicLicenseDescriptor,StartBasicLicenseRequestParameters, IStartBasicLicenseRequest>, IStartBasicLicenseRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>whether the user has acknowledged acknowledge messages (default: false)</summary>
		public StartBasicLicenseDescriptor Acknowledge(bool? acknowledge = true) => Qs("acknowledge", acknowledge);
	}
	///<summary>descriptor for XpackLicensePostStartTrial <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class StartTrialLicenseDescriptor  : RequestDescriptorBase<StartTrialLicenseDescriptor,StartTrialLicenseRequestParameters, IStartTrialLicenseRequest>, IStartTrialLicenseRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>The type of trial license to generate (default: "trial")</summary>
		public StartTrialLicenseDescriptor TypeQueryString(string typeQueryString) => Qs("type", typeQueryString);
		///<summary>whether the user has acknowledged acknowledge messages (default: false)</summary>
		public StartTrialLicenseDescriptor Acknowledge(bool? acknowledge = true) => Qs("acknowledge", acknowledge);
	}
	///<summary>descriptor for XpackMlCloseJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-close-job.html</pre></summary>
	public partial class CloseJobDescriptor  : RequestDescriptorBase<CloseJobDescriptor,CloseJobRequestParameters, ICloseJobRequest>, ICloseJobRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/_close</summary>
		///<param name="job_id"> this parameter is required</param>
		public CloseJobDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id ICloseJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

		///<summary>Whether to ignore if a wildcard expression matches no jobs. (This includes `_all` string or when no jobs have been specified)</summary>
		public CloseJobDescriptor AllowNoJobs(bool? allowNoJobs = true) => Qs("allow_no_jobs", allowNoJobs);
		///<summary>True if the job should be forcefully closed</summary>
		public CloseJobDescriptor Force(bool? force = true) => Qs("force", force);
		///<summary>Controls the time to wait until a job has closed. Default to 30 minutes</summary>
		public CloseJobDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackMlDeleteCalendar <pre></pre></summary>
	public partial class DeleteCalendarDescriptor  : RequestDescriptorBase<DeleteCalendarDescriptor,DeleteCalendarRequestParameters, IDeleteCalendarRequest>, IDeleteCalendarRequest
	{ 
		/// <summary>/_xpack/ml/calendars/{calendar_id}</summary>
		///<param name="calendar_id"> this parameter is required</param>
		public DeleteCalendarDescriptor(Id calendar_id) : base(r=>r.Required("calendar_id", calendar_id)){}
		// values part of the url path
		Id IDeleteCalendarRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlDeleteCalendarEvent <pre></pre></summary>
	public partial class DeleteCalendarEventDescriptor  : RequestDescriptorBase<DeleteCalendarEventDescriptor,DeleteCalendarEventRequestParameters, IDeleteCalendarEventRequest>, IDeleteCalendarEventRequest
	{ 
		/// <summary>/_xpack/ml/calendars/{calendar_id}/events/{event_id}</summary>
		///<param name="calendar_id"> this parameter is required</param>
		///<param name="event_id"> this parameter is required</param>
		public DeleteCalendarEventDescriptor(Id calendar_id, Id event_id) : base(r=>r.Required("calendar_id", calendar_id).Required("event_id", event_id)){}
		// values part of the url path
		Id IDeleteCalendarEventRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		Id IDeleteCalendarEventRequest.EventId => Self.RouteValues.Get<Id>("event_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlDeleteCalendarJob <pre></pre></summary>
	public partial class DeleteCalendarJobDescriptor  : RequestDescriptorBase<DeleteCalendarJobDescriptor,DeleteCalendarJobRequestParameters, IDeleteCalendarJobRequest>, IDeleteCalendarJobRequest
	{ 
		/// <summary>/_xpack/ml/calendars/{calendar_id}/jobs/{job_id}</summary>
		///<param name="calendar_id"> this parameter is required</param>
		///<param name="job_id"> this parameter is required</param>
		public DeleteCalendarJobDescriptor(Id calendar_id, Id job_id) : base(r=>r.Required("calendar_id", calendar_id).Required("job_id", job_id)){}
		// values part of the url path
		Id IDeleteCalendarJobRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		Id IDeleteCalendarJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlDeleteDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-datafeed.html</pre></summary>
	public partial class DeleteDatafeedDescriptor  : RequestDescriptorBase<DeleteDatafeedDescriptor,DeleteDatafeedRequestParameters, IDeleteDatafeedRequest>, IDeleteDatafeedRequest
	{ 
		/// <summary>/_xpack/ml/datafeeds/{datafeed_id}</summary>
		///<param name="datafeed_id"> this parameter is required</param>
		public DeleteDatafeedDescriptor(Id datafeed_id) : base(r=>r.Required("datafeed_id", datafeed_id)){}
		// values part of the url path
		Id IDeleteDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");

		// Request parameters

		///<summary>True if the datafeed should be forcefully deleted</summary>
		public DeleteDatafeedDescriptor Force(bool? force = true) => Qs("force", force);
	}
	///<summary>descriptor for XpackMlDeleteExpiredData <pre></pre></summary>
	public partial class DeleteExpiredDataDescriptor  : RequestDescriptorBase<DeleteExpiredDataDescriptor,DeleteExpiredDataRequestParameters, IDeleteExpiredDataRequest>, IDeleteExpiredDataRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackMlDeleteFilter <pre></pre></summary>
	public partial class DeleteFilterDescriptor  : RequestDescriptorBase<DeleteFilterDescriptor,DeleteFilterRequestParameters, IDeleteFilterRequest>, IDeleteFilterRequest
	{ 
		/// <summary>/_xpack/ml/filters/{filter_id}</summary>
		///<param name="filter_id"> this parameter is required</param>
		public DeleteFilterDescriptor(Id filter_id) : base(r=>r.Required("filter_id", filter_id)){}
		// values part of the url path
		Id IDeleteFilterRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlDeleteForecast <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-forecast.html</pre></summary>
	public partial class DeleteForecastDescriptor  : RequestDescriptorBase<DeleteForecastDescriptor,DeleteForecastRequestParameters, IDeleteForecastRequest>, IDeleteForecastRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/_forecast/{forecast_id}</summary>
		///<param name="job_id"> this parameter is required</param>
		///<param name="forecast_id"> this parameter is required</param>
		public DeleteForecastDescriptor(Id job_id, ForecastIds forecast_id) : base(r=>r.Required("job_id", job_id).Required("forecast_id", forecast_id)){}
		// values part of the url path
		Id IDeleteForecastRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		ForecastIds IDeleteForecastRequest.ForecastId => Self.RouteValues.Get<ForecastIds>("forecast_id");

		// Request parameters

		///<summary>Whether to ignore if `_all` matches no forecasts</summary>
		public DeleteForecastDescriptor AllowNoForecasts(bool? allowNoForecasts = true) => Qs("allow_no_forecasts", allowNoForecasts);
		///<summary>Controls the time to wait until the forecast(s) are deleted. Default to 30 seconds</summary>
		public DeleteForecastDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackMlDeleteJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-job.html</pre></summary>
	public partial class DeleteJobDescriptor  : RequestDescriptorBase<DeleteJobDescriptor,DeleteJobRequestParameters, IDeleteJobRequest>, IDeleteJobRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}</summary>
		///<param name="job_id"> this parameter is required</param>
		public DeleteJobDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IDeleteJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

		///<summary>True if the job should be forcefully deleted</summary>
		public DeleteJobDescriptor Force(bool? force = true) => Qs("force", force);
		///<summary>Should this request wait until the operation has completed before returning</summary>
		public DeleteJobDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}
	///<summary>descriptor for XpackMlDeleteModelSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-snapshot.html</pre></summary>
	public partial class DeleteModelSnapshotDescriptor  : RequestDescriptorBase<DeleteModelSnapshotDescriptor,DeleteModelSnapshotRequestParameters, IDeleteModelSnapshotRequest>, IDeleteModelSnapshotRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}</summary>
		///<param name="job_id"> this parameter is required</param>
		///<param name="snapshot_id"> this parameter is required</param>
		public DeleteModelSnapshotDescriptor(Id job_id, Id snapshot_id) : base(r=>r.Required("job_id", job_id).Required("snapshot_id", snapshot_id)){}
		// values part of the url path
		Id IDeleteModelSnapshotRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		Id IDeleteModelSnapshotRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlFlushJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-flush-job.html</pre></summary>
	public partial class FlushJobDescriptor  : RequestDescriptorBase<FlushJobDescriptor,FlushJobRequestParameters, IFlushJobRequest>, IFlushJobRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/_flush</summary>
		///<param name="job_id"> this parameter is required</param>
		public FlushJobDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IFlushJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

		///<summary>Skips time to the given value without generating results or updating the model for the skipped interval</summary>
		public FlushJobDescriptor SkipTime(string skipTime) => Qs("skip_time", skipTime);
	}
	///<summary>descriptor for XpackMlForecast <pre></pre></summary>
	public partial class ForecastJobDescriptor  : RequestDescriptorBase<ForecastJobDescriptor,ForecastJobRequestParameters, IForecastJobRequest>, IForecastJobRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/_forecast</summary>
		///<param name="job_id"> this parameter is required</param>
		public ForecastJobDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IForecastJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlGetBuckets <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-bucket.html</pre></summary>
	public partial class GetBucketsDescriptor  : RequestDescriptorBase<GetBucketsDescriptor,GetBucketsRequestParameters, IGetBucketsRequest>, IGetBucketsRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/results/buckets</summary>
		///<param name="job_id"> this parameter is required</param>
		public GetBucketsDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IGetBucketsRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlGetCalendars <pre></pre></summary>
	public partial class GetCalendarsDescriptor  : RequestDescriptorBase<GetCalendarsDescriptor,GetCalendarsRequestParameters, IGetCalendarsRequest>, IGetCalendarsRequest
	{ 
		/// <summary>/_xpack/ml/calendars</summary>
		public GetCalendarsDescriptor() : base(){}
		// values part of the url path
		Id IGetCalendarsRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");

		///<summary>The ID of the calendar to fetch</summary>
		public GetCalendarsDescriptor CalendarId(Id calendarId) => Assign(calendarId, (a,v)=>a.RouteValues.Optional("calendar_id", v));

		// Request parameters

	}
	///<summary>descriptor for XpackMlGetCalendarEvents <pre></pre></summary>
	public partial class GetCalendarEventsDescriptor  : RequestDescriptorBase<GetCalendarEventsDescriptor,GetCalendarEventsRequestParameters, IGetCalendarEventsRequest>, IGetCalendarEventsRequest
	{ 
		/// <summary>/_xpack/ml/calendars/{calendar_id}/events</summary>
		///<param name="calendar_id"> this parameter is required</param>
		public GetCalendarEventsDescriptor(Id calendar_id) : base(r=>r.Required("calendar_id", calendar_id)){}
		// values part of the url path
		Id IGetCalendarEventsRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");

		// Request parameters

		///<summary>Get events for the job. When this option is used calendar_id must be '_all'</summary>
		public GetCalendarEventsDescriptor JobId(string jobId) => Qs("job_id", jobId);
		///<summary>Get events after this time</summary>
		public GetCalendarEventsDescriptor Start(string start) => Qs("start", start);
		///<summary>Get events before this time</summary>
		public GetCalendarEventsDescriptor End(DateTimeOffset? end) => Qs("end", end);
	}
	///<summary>descriptor for XpackMlGetCategories <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-category.html</pre></summary>
	public partial class GetCategoriesDescriptor  : RequestDescriptorBase<GetCategoriesDescriptor,GetCategoriesRequestParameters, IGetCategoriesRequest>, IGetCategoriesRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/results/categories/{category_id}</summary>
		///<param name="job_id"> this parameter is required</param>
		public GetCategoriesDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IGetCategoriesRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		CategoryId IGetCategoriesRequest.CategoryId => Self.RouteValues.Get<CategoryId>("category_id");

		///<summary>The identifier of the category definition of interest</summary>
		public GetCategoriesDescriptor CategoryId(CategoryId categoryId) => Assign(categoryId, (a,v)=>a.RouteValues.Optional("category_id", v));

		// Request parameters

	}
	///<summary>descriptor for XpackMlGetDatafeeds <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-datafeed.html</pre></summary>
	public partial class GetDatafeedsDescriptor  : RequestDescriptorBase<GetDatafeedsDescriptor,GetDatafeedsRequestParameters, IGetDatafeedsRequest>, IGetDatafeedsRequest
	{ 
		/// <summary>/_xpack/ml/datafeeds/{datafeed_id}</summary>
		public GetDatafeedsDescriptor() : base(){}
		// values part of the url path
		Id IGetDatafeedsRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");

		///<summary>The ID of the datafeeds to fetch</summary>
		public GetDatafeedsDescriptor DatafeedId(Id datafeedId) => Assign(datafeedId, (a,v)=>a.RouteValues.Optional("datafeed_id", v));

		// Request parameters

		///<summary>Whether to ignore if a wildcard expression matches no datafeeds. (This includes `_all` string or when no datafeeds have been specified)</summary>
		public GetDatafeedsDescriptor AllowNoDatafeeds(bool? allowNoDatafeeds = true) => Qs("allow_no_datafeeds", allowNoDatafeeds);
	}
	///<summary>descriptor for XpackMlGetDatafeedStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-datafeed-stats.html</pre></summary>
	public partial class GetDatafeedStatsDescriptor  : RequestDescriptorBase<GetDatafeedStatsDescriptor,GetDatafeedStatsRequestParameters, IGetDatafeedStatsRequest>, IGetDatafeedStatsRequest
	{ 
		/// <summary>/_xpack/ml/datafeeds/{datafeed_id}/_stats</summary>
		public GetDatafeedStatsDescriptor() : base(){}
		// values part of the url path
		Id IGetDatafeedStatsRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");

		///<summary>The ID of the datafeeds stats to fetch</summary>
		public GetDatafeedStatsDescriptor DatafeedId(Id datafeedId) => Assign(datafeedId, (a,v)=>a.RouteValues.Optional("datafeed_id", v));

		// Request parameters

		///<summary>Whether to ignore if a wildcard expression matches no datafeeds. (This includes `_all` string or when no datafeeds have been specified)</summary>
		public GetDatafeedStatsDescriptor AllowNoDatafeeds(bool? allowNoDatafeeds = true) => Qs("allow_no_datafeeds", allowNoDatafeeds);
	}
	///<summary>descriptor for XpackMlGetFilters <pre></pre></summary>
	public partial class GetFiltersDescriptor  : RequestDescriptorBase<GetFiltersDescriptor,GetFiltersRequestParameters, IGetFiltersRequest>, IGetFiltersRequest
	{ 
		/// <summary>/_xpack/ml/filters</summary>
		public GetFiltersDescriptor() : base(){}
		// values part of the url path
		Id IGetFiltersRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");

		///<summary>The ID of the filter to fetch</summary>
		public GetFiltersDescriptor FilterId(Id filterId) => Assign(filterId, (a,v)=>a.RouteValues.Optional("filter_id", v));

		// Request parameters

		///<summary>skips a number of filters</summary>
		public GetFiltersDescriptor From(int? from) => Qs("from", from);
		///<summary>specifies a max number of filters to get</summary>
		public GetFiltersDescriptor Size(int? size) => Qs("size", size);
	}
	///<summary>descriptor for XpackMlGetInfluencers <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-influencer.html</pre></summary>
	public partial class GetInfluencersDescriptor  : RequestDescriptorBase<GetInfluencersDescriptor,GetInfluencersRequestParameters, IGetInfluencersRequest>, IGetInfluencersRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/results/influencers</summary>
		///<param name="job_id"> this parameter is required</param>
		public GetInfluencersDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IGetInfluencersRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlGetJobs <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job.html</pre></summary>
	public partial class GetJobsDescriptor  : RequestDescriptorBase<GetJobsDescriptor,GetJobsRequestParameters, IGetJobsRequest>, IGetJobsRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}</summary>
		public GetJobsDescriptor() : base(){}
		// values part of the url path
		Id IGetJobsRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		///<summary>The ID of the jobs to fetch</summary>
		public GetJobsDescriptor JobId(Id jobId) => Assign(jobId, (a,v)=>a.RouteValues.Optional("job_id", v));

		// Request parameters

		///<summary>Whether to ignore if a wildcard expression matches no jobs. (This includes `_all` string or when no jobs have been specified)</summary>
		public GetJobsDescriptor AllowNoJobs(bool? allowNoJobs = true) => Qs("allow_no_jobs", allowNoJobs);
	}
	///<summary>descriptor for XpackMlGetJobStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job-stats.html</pre></summary>
	public partial class GetJobStatsDescriptor  : RequestDescriptorBase<GetJobStatsDescriptor,GetJobStatsRequestParameters, IGetJobStatsRequest>, IGetJobStatsRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/_stats</summary>
		public GetJobStatsDescriptor() : base(){}
		// values part of the url path
		Id IGetJobStatsRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		///<summary>The ID of the jobs stats to fetch</summary>
		public GetJobStatsDescriptor JobId(Id jobId) => Assign(jobId, (a,v)=>a.RouteValues.Optional("job_id", v));

		// Request parameters

		///<summary>Whether to ignore if a wildcard expression matches no jobs. (This includes `_all` string or when no jobs have been specified)</summary>
		public GetJobStatsDescriptor AllowNoJobs(bool? allowNoJobs = true) => Qs("allow_no_jobs", allowNoJobs);
	}
	///<summary>descriptor for XpackMlGetModelSnapshots <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-snapshot.html</pre></summary>
	public partial class GetModelSnapshotsDescriptor  : RequestDescriptorBase<GetModelSnapshotsDescriptor,GetModelSnapshotsRequestParameters, IGetModelSnapshotsRequest>, IGetModelSnapshotsRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}</summary>
		///<param name="job_id"> this parameter is required</param>
		public GetModelSnapshotsDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IGetModelSnapshotsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		Id IGetModelSnapshotsRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");

		///<summary>The ID of the snapshot to fetch</summary>
		public GetModelSnapshotsDescriptor SnapshotId(Id snapshotId) => Assign(snapshotId, (a,v)=>a.RouteValues.Optional("snapshot_id", v));

		// Request parameters

	}
	///<summary>descriptor for XpackMlGetOverallBuckets <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-overall-buckets.html</pre></summary>
	public partial class GetOverallBucketsDescriptor  : RequestDescriptorBase<GetOverallBucketsDescriptor,GetOverallBucketsRequestParameters, IGetOverallBucketsRequest>, IGetOverallBucketsRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/results/overall_buckets</summary>
		///<param name="job_id"> this parameter is required</param>
		public GetOverallBucketsDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IGetOverallBucketsRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlGetRecords <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-record.html</pre></summary>
	public partial class GetAnomalyRecordsDescriptor  : RequestDescriptorBase<GetAnomalyRecordsDescriptor,GetAnomalyRecordsRequestParameters, IGetAnomalyRecordsRequest>, IGetAnomalyRecordsRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/results/records</summary>
		///<param name="job_id"> this parameter is required</param>
		public GetAnomalyRecordsDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IGetAnomalyRecordsRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlInfo <pre></pre></summary>
	public partial class MachineLearningInfoDescriptor  : RequestDescriptorBase<MachineLearningInfoDescriptor,MachineLearningInfoRequestParameters, IMachineLearningInfoRequest>, IMachineLearningInfoRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackMlOpenJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-open-job.html</pre></summary>
	public partial class OpenJobDescriptor  : RequestDescriptorBase<OpenJobDescriptor,OpenJobRequestParameters, IOpenJobRequest>, IOpenJobRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/_open</summary>
		///<param name="job_id"> this parameter is required</param>
		public OpenJobDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IOpenJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlPostCalendarEvents <pre></pre></summary>
	public partial class PostCalendarEventsDescriptor  : RequestDescriptorBase<PostCalendarEventsDescriptor,PostCalendarEventsRequestParameters, IPostCalendarEventsRequest>, IPostCalendarEventsRequest
	{ 
		/// <summary>/_xpack/ml/calendars/{calendar_id}/events</summary>
		///<param name="calendar_id"> this parameter is required</param>
		public PostCalendarEventsDescriptor(Id calendar_id) : base(r=>r.Required("calendar_id", calendar_id)){}
		// values part of the url path
		Id IPostCalendarEventsRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlPostData <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-post-data.html</pre></summary>
	public partial class PostJobDataDescriptor  : RequestDescriptorBase<PostJobDataDescriptor,PostJobDataRequestParameters, IPostJobDataRequest>, IPostJobDataRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/_data</summary>
		///<param name="job_id"> this parameter is required</param>
		public PostJobDataDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IPostJobDataRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

		///<summary>Optional parameter to specify the start of the bucket resetting range</summary>
		public PostJobDataDescriptor ResetStart(DateTimeOffset? resetStart) => Qs("reset_start", resetStart);
		///<summary>Optional parameter to specify the end of the bucket resetting range</summary>
		public PostJobDataDescriptor ResetEnd(DateTimeOffset? resetEnd) => Qs("reset_end", resetEnd);
	}
	///<summary>descriptor for XpackMlPreviewDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-preview-datafeed.html</pre></summary>
	public partial class PreviewDatafeedDescriptor  : RequestDescriptorBase<PreviewDatafeedDescriptor,PreviewDatafeedRequestParameters, IPreviewDatafeedRequest>, IPreviewDatafeedRequest
	{ 
		/// <summary>/_xpack/ml/datafeeds/{datafeed_id}/_preview</summary>
		///<param name="datafeed_id"> this parameter is required</param>
		public PreviewDatafeedDescriptor(Id datafeed_id) : base(r=>r.Required("datafeed_id", datafeed_id)){}
		// values part of the url path
		Id IPreviewDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlPutCalendar <pre></pre></summary>
	public partial class PutCalendarDescriptor  : RequestDescriptorBase<PutCalendarDescriptor,PutCalendarRequestParameters, IPutCalendarRequest>, IPutCalendarRequest
	{ 
		/// <summary>/_xpack/ml/calendars/{calendar_id}</summary>
		///<param name="calendar_id"> this parameter is required</param>
		public PutCalendarDescriptor(Id calendar_id) : base(r=>r.Required("calendar_id", calendar_id)){}
		// values part of the url path
		Id IPutCalendarRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlPutCalendarJob <pre></pre></summary>
	public partial class PutCalendarJobDescriptor  : RequestDescriptorBase<PutCalendarJobDescriptor,PutCalendarJobRequestParameters, IPutCalendarJobRequest>, IPutCalendarJobRequest
	{ 
		/// <summary>/_xpack/ml/calendars/{calendar_id}/jobs/{job_id}</summary>
		///<param name="calendar_id"> this parameter is required</param>
		///<param name="job_id"> this parameter is required</param>
		public PutCalendarJobDescriptor(Id calendar_id, Id job_id) : base(r=>r.Required("calendar_id", calendar_id).Required("job_id", job_id)){}
		// values part of the url path
		Id IPutCalendarJobRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		Id IPutCalendarJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlPutDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-datafeed.html</pre></summary>
	public partial class PutDatafeedDescriptor<T>  : RequestDescriptorBase<PutDatafeedDescriptor<T>,PutDatafeedRequestParameters, IPutDatafeedRequest>, IPutDatafeedRequest
	{ 
		/// <summary>/_xpack/ml/datafeeds/{datafeed_id}. Will infer the index and type from the generic type</summary>
		///<param name="datafeed_id"> this parameter is required</param>
		public PutDatafeedDescriptor(Id datafeed_id) : base(r=>r.Required("datafeed_id", datafeed_id))
		{ Self.Indices = typeof(T); Self.Types = typeof(T);  }
		// values part of the url path
		Id IPutDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlPutFilter <pre></pre></summary>
	public partial class PutFilterDescriptor  : RequestDescriptorBase<PutFilterDescriptor,PutFilterRequestParameters, IPutFilterRequest>, IPutFilterRequest
	{ 
		/// <summary>/_xpack/ml/filters/{filter_id}</summary>
		///<param name="filter_id"> this parameter is required</param>
		public PutFilterDescriptor(Id filter_id) : base(r=>r.Required("filter_id", filter_id)){}
		// values part of the url path
		Id IPutFilterRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlPutJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-job.html</pre></summary>
	public partial class PutJobDescriptor<T>  : RequestDescriptorBase<PutJobDescriptor<T>,PutJobRequestParameters, IPutJobRequest>, IPutJobRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}</summary>
		///<param name="job_id"> this parameter is required</param>
		public PutJobDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IPutJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlRevertModelSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-revert-snapshot.html</pre></summary>
	public partial class RevertModelSnapshotDescriptor  : RequestDescriptorBase<RevertModelSnapshotDescriptor,RevertModelSnapshotRequestParameters, IRevertModelSnapshotRequest>, IRevertModelSnapshotRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_revert</summary>
		///<param name="job_id"> this parameter is required</param>
		///<param name="snapshot_id"> this parameter is required</param>
		public RevertModelSnapshotDescriptor(Id job_id, Id snapshot_id) : base(r=>r.Required("job_id", job_id).Required("snapshot_id", snapshot_id)){}
		// values part of the url path
		Id IRevertModelSnapshotRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		Id IRevertModelSnapshotRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlStartDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-start-datafeed.html</pre></summary>
	public partial class StartDatafeedDescriptor  : RequestDescriptorBase<StartDatafeedDescriptor,StartDatafeedRequestParameters, IStartDatafeedRequest>, IStartDatafeedRequest
	{ 
		/// <summary>/_xpack/ml/datafeeds/{datafeed_id}/_start</summary>
		///<param name="datafeed_id"> this parameter is required</param>
		public StartDatafeedDescriptor(Id datafeed_id) : base(r=>r.Required("datafeed_id", datafeed_id)){}
		// values part of the url path
		Id IStartDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlStopDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-stop-datafeed.html</pre></summary>
	public partial class StopDatafeedDescriptor  : RequestDescriptorBase<StopDatafeedDescriptor,StopDatafeedRequestParameters, IStopDatafeedRequest>, IStopDatafeedRequest
	{ 
		/// <summary>/_xpack/ml/datafeeds/{datafeed_id}/_stop</summary>
		///<param name="datafeed_id"> this parameter is required</param>
		public StopDatafeedDescriptor(Id datafeed_id) : base(r=>r.Required("datafeed_id", datafeed_id)){}
		// values part of the url path
		Id IStopDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");

		// Request parameters

		///<summary>Whether to ignore if a wildcard expression matches no datafeeds. (This includes `_all` string or when no datafeeds have been specified)</summary>
		public StopDatafeedDescriptor AllowNoDatafeeds(bool? allowNoDatafeeds = true) => Qs("allow_no_datafeeds", allowNoDatafeeds);
	}
	///<summary>descriptor for XpackMlUpdateDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-datafeed.html</pre></summary>
	public partial class UpdateDatafeedDescriptor<T>  : RequestDescriptorBase<UpdateDatafeedDescriptor<T>,UpdateDatafeedRequestParameters, IUpdateDatafeedRequest>, IUpdateDatafeedRequest
	{ 
		/// <summary>/_xpack/ml/datafeeds/{datafeed_id}/_update. Will infer the index and type from the generic type</summary>
		///<param name="datafeed_id"> this parameter is required</param>
		public UpdateDatafeedDescriptor(Id datafeed_id) : base(r=>r.Required("datafeed_id", datafeed_id))
		{ Self.Indices = typeof(T); Self.Types = typeof(T);  }
		// values part of the url path
		Id IUpdateDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlUpdateFilter <pre></pre></summary>
	public partial class UpdateFilterDescriptor  : RequestDescriptorBase<UpdateFilterDescriptor,UpdateFilterRequestParameters, IUpdateFilterRequest>, IUpdateFilterRequest
	{ 
		/// <summary>/_xpack/ml/filters/{filter_id}/_update</summary>
		///<param name="filter_id"> this parameter is required</param>
		public UpdateFilterDescriptor(Id filter_id) : base(r=>r.Required("filter_id", filter_id)){}
		// values part of the url path
		Id IUpdateFilterRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlUpdateJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-job.html</pre></summary>
	public partial class UpdateJobDescriptor<T>  : RequestDescriptorBase<UpdateJobDescriptor<T>,UpdateJobRequestParameters, IUpdateJobRequest>, IUpdateJobRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/_update</summary>
		///<param name="job_id"> this parameter is required</param>
		public UpdateJobDescriptor(Id job_id) : base(r=>r.Required("job_id", job_id)){}
		// values part of the url path
		Id IUpdateJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlUpdateModelSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-snapshot.html</pre></summary>
	public partial class UpdateModelSnapshotDescriptor  : RequestDescriptorBase<UpdateModelSnapshotDescriptor,UpdateModelSnapshotRequestParameters, IUpdateModelSnapshotRequest>, IUpdateModelSnapshotRequest
	{ 
		/// <summary>/_xpack/ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_update</summary>
		///<param name="job_id"> this parameter is required</param>
		///<param name="snapshot_id"> this parameter is required</param>
		public UpdateModelSnapshotDescriptor(Id job_id, Id snapshot_id) : base(r=>r.Required("job_id", job_id).Required("snapshot_id", snapshot_id)){}
		// values part of the url path
		Id IUpdateModelSnapshotRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		Id IUpdateModelSnapshotRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");

		// Request parameters

	}
	///<summary>descriptor for XpackMlValidate <pre></pre></summary>
	public partial class ValidateJobDescriptor<T>  : RequestDescriptorBase<ValidateJobDescriptor<T>,ValidateJobRequestParameters, IValidateJobRequest>, IValidateJobRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackMlValidateDetector <pre></pre></summary>
	public partial class ValidateDetectorDescriptor<T>  : RequestDescriptorBase<ValidateDetectorDescriptor<T>,ValidateDetectorRequestParameters, IValidateDetectorRequest>, IValidateDetectorRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackMigrationDeprecations <pre>http://www.elastic.co/guide/en/migration/current/migration-api-deprecation.html</pre></summary>
	public partial class DeprecationInfoDescriptor  : RequestDescriptorBase<DeprecationInfoDescriptor,DeprecationInfoRequestParameters, IDeprecationInfoRequest>, IDeprecationInfoRequest
	{ 
		/// <summary>/_xpack/migration/deprecations</summary>
		public DeprecationInfoDescriptor() : base(){}
		// values part of the url path
		IndexName IDeprecationInfoRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>Index pattern</summary>
		public DeprecationInfoDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DeprecationInfoDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (IndexName)v));

		// Request parameters

	}
	///<summary>descriptor for XpackMigrationGetAssistance <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/migration-api-assistance.html</pre></summary>
	public partial class MigrationAssistanceDescriptor  : RequestDescriptorBase<MigrationAssistanceDescriptor,MigrationAssistanceRequestParameters, IMigrationAssistanceRequest>, IMigrationAssistanceRequest
	{ 
		/// <summary>/_xpack/migration/assistance</summary>
		public MigrationAssistanceDescriptor() : base(){}
		// values part of the url path
		Indices IMigrationAssistanceRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public MigrationAssistanceDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MigrationAssistanceDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public MigrationAssistanceDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public MigrationAssistanceDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public MigrationAssistanceDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public MigrationAssistanceDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	}
	///<summary>descriptor for XpackMigrationUpgrade <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/migration-api-upgrade.html</pre></summary>
	public partial class MigrationUpgradeDescriptor  : RequestDescriptorBase<MigrationUpgradeDescriptor,MigrationUpgradeRequestParameters, IMigrationUpgradeRequest>, IMigrationUpgradeRequest
	{ 
		/// <summary>/_xpack/migration/upgrade/{index}</summary>
		///<param name="index"> this parameter is required</param>
		public MigrationUpgradeDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		IndexName IMigrationUpgradeRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The name of the index</summary>
		public MigrationUpgradeDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MigrationUpgradeDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

		///<summary>Should the request block until the upgrade operation is completed</summary>
		public MigrationUpgradeDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}
	///<summary>descriptor for XpackRollupDeleteJob <pre></pre></summary>
	public partial class DeleteRollupJobDescriptor  : RequestDescriptorBase<DeleteRollupJobDescriptor,DeleteRollupJobRequestParameters, IDeleteRollupJobRequest>, IDeleteRollupJobRequest
	{ 
		/// <summary>/_xpack/rollup/job/{id}</summary>
		///<param name="id"> this parameter is required</param>
		public DeleteRollupJobDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id IDeleteRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");

		// Request parameters

	}
	///<summary>descriptor for XpackRollupGetJobs <pre></pre></summary>
	public partial class GetRollupJobDescriptor  : RequestDescriptorBase<GetRollupJobDescriptor,GetRollupJobRequestParameters, IGetRollupJobRequest>, IGetRollupJobRequest
	{ 
		/// <summary>/_xpack/rollup/job/{id}</summary>
		public GetRollupJobDescriptor() : base(){}
		// values part of the url path
		Id IGetRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");

		///<summary>The ID of the job(s) to fetch. Accepts glob patterns, or left blank for all jobs</summary>
		public GetRollupJobDescriptor Id(Id id) => Assign(id, (a,v)=>a.RouteValues.Optional("id", v));

		// Request parameters

	}
	///<summary>descriptor for XpackRollupGetRollupCaps <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/rollup-get-rollup-caps.html</pre></summary>
	public partial class GetRollupCapabilitiesDescriptor  : RequestDescriptorBase<GetRollupCapabilitiesDescriptor,GetRollupCapabilitiesRequestParameters, IGetRollupCapabilitiesRequest>, IGetRollupCapabilitiesRequest
	{ 
		/// <summary>/_xpack/rollup/data/{index}</summary>
		public GetRollupCapabilitiesDescriptor() : base(){}
		// values part of the url path
		Indices IGetRollupCapabilitiesRequest.Index => Self.RouteValues.Get<Indices>("index");

		///<summary> Index, indices or index-pattern to return rollup capabilities for. _all may be used to fetch rollup capabilities from all job</summary>
		public GetRollupCapabilitiesDescriptor Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Optional("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetRollupCapabilitiesDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GetRollupCapabilitiesDescriptor AllIndices() => this.Index(Indices.All);

		// Request parameters

	}
	///<summary>descriptor for XpackRollupGetRollupIndexCaps <pre></pre></summary>
	public partial class GetRollupIndexCapabilitiesDescriptor  : RequestDescriptorBase<GetRollupIndexCapabilitiesDescriptor,GetRollupIndexCapabilitiesRequestParameters, IGetRollupIndexCapabilitiesRequest>, IGetRollupIndexCapabilitiesRequest
	{ 
		/// <summary>/{index}/_xpack/rollup/data</summary>
		///<param name="index"> this parameter is required</param>
		public GetRollupIndexCapabilitiesDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		IndexName IGetRollupIndexCapabilitiesRequest.Index => Self.RouteValues.Get<IndexName>("index");

		///<summary>The rollup index or index pattern to obtain rollup capabilities from.</summary>
		public GetRollupIndexCapabilitiesDescriptor Index(IndexName index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetRollupIndexCapabilitiesDescriptor Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (IndexName)v));

		// Request parameters

	}
	///<summary>descriptor for XpackRollupPutJob <pre></pre></summary>
	public partial class CreateRollupJobDescriptor<T>  : RequestDescriptorBase<CreateRollupJobDescriptor<T>,CreateRollupJobRequestParameters, ICreateRollupJobRequest>, ICreateRollupJobRequest
	{ 
		/// <summary>/_xpack/rollup/job/{id}</summary>
		///<param name="id"> this parameter is required</param>
		public CreateRollupJobDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id ICreateRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");

		// Request parameters

	}
	///<summary>descriptor for XpackRollupRollupSearch <pre></pre></summary>
	public partial class RollupSearchDescriptor<T>  : RequestDescriptorBase<RollupSearchDescriptor<T>,RollupSearchRequestParameters, IRollupSearchRequest>, IRollupSearchRequest
	{ 
		/// <summary>/{index}/_rollup_search</summary>
		///<param name="index"> this parameter is required</param>
		public RollupSearchDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		// values part of the url path
		Indices IRollupSearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		TypeName IRollupSearchRequest.Type => Self.RouteValues.Get<TypeName>("type");

		///<summary>The index or index-pattern (containing rollup or regular data) that should be searched</summary>
		public RollupSearchDescriptor<T> Index(Indices index) => Assign(index, (a,v)=>a.RouteValues.Required("index", v));

		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public RollupSearchDescriptor<T> Index<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Required("index", (Indices)v));

		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public RollupSearchDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>The doc type inside the index</summary>
		public RollupSearchDescriptor<T> Type(TypeName type) => Assign(type, (a,v)=>a.RouteValues.Optional("type", v));

		///<summary>a shortcut into calling Type(typeof(TOther))</summary>
		public RollupSearchDescriptor<T> Type<TOther>() where TOther : class => Assign(typeof(TOther), (a,v)=>a.RouteValues.Optional("type", (TypeName)v));

		// Request parameters

		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public RollupSearchDescriptor<T> TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	}
	///<summary>descriptor for XpackRollupStartJob <pre></pre></summary>
	public partial class StartRollupJobDescriptor  : RequestDescriptorBase<StartRollupJobDescriptor,StartRollupJobRequestParameters, IStartRollupJobRequest>, IStartRollupJobRequest
	{ 
		/// <summary>/_xpack/rollup/job/{id}/_start</summary>
		///<param name="id"> this parameter is required</param>
		public StartRollupJobDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id IStartRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");

		// Request parameters

	}
	///<summary>descriptor for XpackRollupStopJob <pre></pre></summary>
	public partial class StopRollupJobDescriptor  : RequestDescriptorBase<StopRollupJobDescriptor,StopRollupJobRequestParameters, IStopRollupJobRequest>, IStopRollupJobRequest
	{ 
		/// <summary>/_xpack/rollup/job/{id}/_stop</summary>
		///<param name="id"> this parameter is required</param>
		public StopRollupJobDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id IStopRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");

		// Request parameters

		///<summary>True if the API should block until the job has fully stopped, false if should be executed async. Defaults to false.</summary>
		public StopRollupJobDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
		///<summary>Block for (at maximum) the specified duration while waiting for the job to stop.  Defaults to 30s.</summary>
		public StopRollupJobDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}
	///<summary>descriptor for XpackSecurityCreateApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html</pre></summary>
	public partial class CreateApiKeyDescriptor  : RequestDescriptorBase<CreateApiKeyDescriptor,CreateApiKeyRequestParameters, ICreateApiKeyRequest>, ICreateApiKeyRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public CreateApiKeyDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSecurityGetApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-api-key.html</pre></summary>
	public partial class GetApiKeyDescriptor  : RequestDescriptorBase<GetApiKeyDescriptor,GetApiKeyRequestParameters, IGetApiKeyRequest>, IGetApiKeyRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>API key id of the API key to be retrieved</summary>
		public GetApiKeyDescriptor Id(string id) => Qs("id", id);
		///<summary>API key name of the API key to be retrieved</summary>
		public GetApiKeyDescriptor Name(string name) => Qs("name", name);
		///<summary>user name of the user who created this API key to be retrieved</summary>
		public GetApiKeyDescriptor Username(string username) => Qs("username", username);
		///<summary>realm name of the user who created this API key to be retrieved</summary>
		public GetApiKeyDescriptor RealmName(string realmName) => Qs("realm_name", realmName);
	}
	///<summary>descriptor for XpackSecurityInvalidateApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-api-key.html</pre></summary>
	public partial class InvalidateApiKeyDescriptor  : RequestDescriptorBase<InvalidateApiKeyDescriptor,InvalidateApiKeyRequestParameters, IInvalidateApiKeyRequest>, IInvalidateApiKeyRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackSecurityAuthenticate <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-authenticate.html</pre></summary>
	public partial class AuthenticateDescriptor  : RequestDescriptorBase<AuthenticateDescriptor,AuthenticateRequestParameters, IAuthenticateRequest>, IAuthenticateRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackSecurityChangePassword <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-change-password.html</pre></summary>
	public partial class ChangePasswordDescriptor  : RequestDescriptorBase<ChangePasswordDescriptor,ChangePasswordRequestParameters, IChangePasswordRequest>, IChangePasswordRequest
	{ 
		/// <summary>/_xpack/security/user/{username}/_password</summary>
		public ChangePasswordDescriptor() : base(){}
		// values part of the url path
		Name IChangePasswordRequest.Username => Self.RouteValues.Get<Name>("username");

		///<summary>The username of the user to change the password for</summary>
		public ChangePasswordDescriptor Username(Name username) => Assign(username, (a,v)=>a.RouteValues.Optional("username", v));

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public ChangePasswordDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSecurityClearCachedRealms <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-cache.html</pre></summary>
	public partial class ClearCachedRealmsDescriptor  : RequestDescriptorBase<ClearCachedRealmsDescriptor,ClearCachedRealmsRequestParameters, IClearCachedRealmsRequest>, IClearCachedRealmsRequest
	{ 
		/// <summary>/_xpack/security/realm/{realms}/_clear_cache</summary>
		///<param name="realms"> this parameter is required</param>
		public ClearCachedRealmsDescriptor(Names realms) : base(r=>r.Required("realms", realms)){}
		// values part of the url path
		Names IClearCachedRealmsRequest.Realms => Self.RouteValues.Get<Names>("realms");

		// Request parameters

		///<summary>Comma-separated list of usernames to clear from the cache</summary>
		public ClearCachedRealmsDescriptor Usernames(params string[] usernames) => Qs("usernames", usernames);
	}
	///<summary>descriptor for XpackSecurityClearCachedRoles <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-role-cache.html</pre></summary>
	public partial class ClearCachedRolesDescriptor  : RequestDescriptorBase<ClearCachedRolesDescriptor,ClearCachedRolesRequestParameters, IClearCachedRolesRequest>, IClearCachedRolesRequest
	{ 
		/// <summary>/_xpack/security/role/{name}/_clear_cache</summary>
		///<param name="name"> this parameter is required</param>
		public ClearCachedRolesDescriptor(Names name) : base(r=>r.Required("name", name)){}
		// values part of the url path
		Names IClearCachedRolesRequest.Name => Self.RouteValues.Get<Names>("name");

		// Request parameters

	}
	///<summary>descriptor for XpackSecurityDeletePrivileges <pre>TODO</pre></summary>
	public partial class DeletePrivilegesDescriptor  : RequestDescriptorBase<DeletePrivilegesDescriptor,DeletePrivilegesRequestParameters, IDeletePrivilegesRequest>, IDeletePrivilegesRequest
	{ 
		/// <summary>/_xpack/security/privilege/{application}/{name}</summary>
		///<param name="application"> this parameter is required</param>
		///<param name="name"> this parameter is required</param>
		public DeletePrivilegesDescriptor(Name application, Name name) : base(r=>r.Required("application", application).Required("name", name)){}
		// values part of the url path
		Name IDeletePrivilegesRequest.Application => Self.RouteValues.Get<Name>("application");
		Name IDeletePrivilegesRequest.Name => Self.RouteValues.Get<Name>("name");

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public DeletePrivilegesDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSecurityDeleteRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-role.html</pre></summary>
	public partial class DeleteRoleDescriptor  : RequestDescriptorBase<DeleteRoleDescriptor,DeleteRoleRequestParameters, IDeleteRoleRequest>, IDeleteRoleRequest
	{ 
		/// <summary>/_xpack/security/role/{name}</summary>
		///<param name="name"> this parameter is required</param>
		public DeleteRoleDescriptor(Name name) : base(r=>r.Required("name", name)){}
		// values part of the url path
		Name IDeleteRoleRequest.Name => Self.RouteValues.Get<Name>("name");

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public DeleteRoleDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSecurityDeleteRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-role-mapping.html</pre></summary>
	public partial class DeleteRoleMappingDescriptor  : RequestDescriptorBase<DeleteRoleMappingDescriptor,DeleteRoleMappingRequestParameters, IDeleteRoleMappingRequest>, IDeleteRoleMappingRequest
	{ 
		/// <summary>/_xpack/security/role_mapping/{name}</summary>
		///<param name="name"> this parameter is required</param>
		public DeleteRoleMappingDescriptor(Name name) : base(r=>r.Required("name", name)){}
		// values part of the url path
		Name IDeleteRoleMappingRequest.Name => Self.RouteValues.Get<Name>("name");

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public DeleteRoleMappingDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSecurityDeleteUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-user.html</pre></summary>
	public partial class DeleteUserDescriptor  : RequestDescriptorBase<DeleteUserDescriptor,DeleteUserRequestParameters, IDeleteUserRequest>, IDeleteUserRequest
	{ 
		/// <summary>/_xpack/security/user/{username}</summary>
		///<param name="username"> this parameter is required</param>
		public DeleteUserDescriptor(Name username) : base(r=>r.Required("username", username)){}
		// values part of the url path
		Name IDeleteUserRequest.Username => Self.RouteValues.Get<Name>("username");

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public DeleteUserDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSecurityDisableUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-disable-user.html</pre></summary>
	public partial class DisableUserDescriptor  : RequestDescriptorBase<DisableUserDescriptor,DisableUserRequestParameters, IDisableUserRequest>, IDisableUserRequest
	{ 
		/// <summary>/_xpack/security/user/{username}/_disable</summary>
		///<param name="username"> this parameter is required</param>
		public DisableUserDescriptor(Name username) : base(r=>r.Required("username", username)){}
		// values part of the url path
		Name IDisableUserRequest.Username => Self.RouteValues.Get<Name>("username");

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public DisableUserDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSecurityEnableUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-enable-user.html</pre></summary>
	public partial class EnableUserDescriptor  : RequestDescriptorBase<EnableUserDescriptor,EnableUserRequestParameters, IEnableUserRequest>, IEnableUserRequest
	{ 
		/// <summary>/_xpack/security/user/{username}/_enable</summary>
		///<param name="username"> this parameter is required</param>
		public EnableUserDescriptor(Name username) : base(r=>r.Required("username", username)){}
		// values part of the url path
		Name IEnableUserRequest.Username => Self.RouteValues.Get<Name>("username");

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public EnableUserDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSecurityGetPrivileges <pre>TODO</pre></summary>
	public partial class GetPrivilegesDescriptor  : RequestDescriptorBase<GetPrivilegesDescriptor,GetPrivilegesRequestParameters, IGetPrivilegesRequest>, IGetPrivilegesRequest
	{ 
		/// <summary>/_xpack/security/privilege</summary>
		public GetPrivilegesDescriptor() : base(){}
		// values part of the url path
		Name IGetPrivilegesRequest.Application => Self.RouteValues.Get<Name>("application");
		Name IGetPrivilegesRequest.Name => Self.RouteValues.Get<Name>("name");

		///<summary>Application name</summary>
		public GetPrivilegesDescriptor Application(Name application) => Assign(application, (a,v)=>a.RouteValues.Optional("application", v));

		///<summary>Privilege name</summary>
		public GetPrivilegesDescriptor Name(Name name) => Assign(name, (a,v)=>a.RouteValues.Optional("name", v));

		// Request parameters

	}
	///<summary>descriptor for XpackSecurityGetRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role.html</pre></summary>
	public partial class GetRoleDescriptor  : RequestDescriptorBase<GetRoleDescriptor,GetRoleRequestParameters, IGetRoleRequest>, IGetRoleRequest
	{ 
		/// <summary>/_xpack/security/role/{name}</summary>
		public GetRoleDescriptor() : base(){}
		// values part of the url path
		Name IGetRoleRequest.Name => Self.RouteValues.Get<Name>("name");

		///<summary>Role name</summary>
		public GetRoleDescriptor Name(Name name) => Assign(name, (a,v)=>a.RouteValues.Optional("name", v));

		// Request parameters

	}
	///<summary>descriptor for XpackSecurityGetRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role-mapping.html</pre></summary>
	public partial class GetRoleMappingDescriptor  : RequestDescriptorBase<GetRoleMappingDescriptor,GetRoleMappingRequestParameters, IGetRoleMappingRequest>, IGetRoleMappingRequest
	{ 
		/// <summary>/_xpack/security/role_mapping/{name}</summary>
		public GetRoleMappingDescriptor() : base(){}
		// values part of the url path
		Name IGetRoleMappingRequest.Name => Self.RouteValues.Get<Name>("name");

		///<summary>Role-Mapping name</summary>
		public GetRoleMappingDescriptor Name(Name name) => Assign(name, (a,v)=>a.RouteValues.Optional("name", v));

		// Request parameters

	}
	///<summary>descriptor for XpackSecurityGetToken <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-token.html</pre></summary>
	public partial class GetUserAccessTokenDescriptor  : RequestDescriptorBase<GetUserAccessTokenDescriptor,GetUserAccessTokenRequestParameters, IGetUserAccessTokenRequest>, IGetUserAccessTokenRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackSecurityGetUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user.html</pre></summary>
	public partial class GetUserDescriptor  : RequestDescriptorBase<GetUserDescriptor,GetUserRequestParameters, IGetUserRequest>, IGetUserRequest
	{ 
		/// <summary>/_xpack/security/user/{username}</summary>
		public GetUserDescriptor() : base(){}
		// values part of the url path
		Names IGetUserRequest.Username => Self.RouteValues.Get<Names>("username");

		///<summary>A comma-separated list of usernames</summary>
		public GetUserDescriptor Username(Names username) => Assign(username, (a,v)=>a.RouteValues.Optional("username", v));

		// Request parameters

	}
	///<summary>descriptor for XpackSecurityGetUserPrivileges <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user-privileges.html</pre></summary>
	public partial class GetUserPrivilegesDescriptor  : RequestDescriptorBase<GetUserPrivilegesDescriptor,GetUserPrivilegesRequestParameters, IGetUserPrivilegesRequest>, IGetUserPrivilegesRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackSecurityHasPrivileges <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-has-privileges.html</pre></summary>
	public partial class HasPrivilegesDescriptor  : RequestDescriptorBase<HasPrivilegesDescriptor,HasPrivilegesRequestParameters, IHasPrivilegesRequest>, IHasPrivilegesRequest
	{ 
		/// <summary>/_xpack/security/user/_has_privileges</summary>
		public HasPrivilegesDescriptor() : base(){}
		// values part of the url path
		Name IHasPrivilegesRequest.User => Self.RouteValues.Get<Name>("user");

		///<summary>Username</summary>
		public HasPrivilegesDescriptor User(Name user) => Assign(user, (a,v)=>a.RouteValues.Optional("user", v));

		// Request parameters

		//TODO THIS METHOD IS UNMAPPED!
		
	}
	///<summary>descriptor for XpackSecurityInvalidateToken <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-token.html</pre></summary>
	public partial class InvalidateUserAccessTokenDescriptor  : RequestDescriptorBase<InvalidateUserAccessTokenDescriptor,InvalidateUserAccessTokenRequestParameters, IInvalidateUserAccessTokenRequest>, IInvalidateUserAccessTokenRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackSecurityPutPrivileges <pre>TODO</pre></summary>
	public partial class PutPrivilegesDescriptor  : RequestDescriptorBase<PutPrivilegesDescriptor,PutPrivilegesRequestParameters, IPutPrivilegesRequest>, IPutPrivilegesRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public PutPrivilegesDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSecurityPutRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role.html</pre></summary>
	public partial class PutRoleDescriptor  : RequestDescriptorBase<PutRoleDescriptor,PutRoleRequestParameters, IPutRoleRequest>, IPutRoleRequest
	{ 
		/// <summary>/_xpack/security/role/{name}</summary>
		///<param name="name"> this parameter is required</param>
		public PutRoleDescriptor(Name name) : base(r=>r.Required("name", name)){}
		// values part of the url path
		Name IPutRoleRequest.Name => Self.RouteValues.Get<Name>("name");

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public PutRoleDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSecurityPutRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role-mapping.html</pre></summary>
	public partial class PutRoleMappingDescriptor  : RequestDescriptorBase<PutRoleMappingDescriptor,PutRoleMappingRequestParameters, IPutRoleMappingRequest>, IPutRoleMappingRequest
	{ 
		/// <summary>/_xpack/security/role_mapping/{name}</summary>
		///<param name="name"> this parameter is required</param>
		public PutRoleMappingDescriptor(Name name) : base(r=>r.Required("name", name)){}
		// values part of the url path
		Name IPutRoleMappingRequest.Name => Self.RouteValues.Get<Name>("name");

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public PutRoleMappingDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSecurityPutUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-user.html</pre></summary>
	public partial class PutUserDescriptor  : RequestDescriptorBase<PutUserDescriptor,PutUserRequestParameters, IPutUserRequest>, IPutUserRequest
	{ 
		/// <summary>/_xpack/security/user/{username}</summary>
		///<param name="username"> this parameter is required</param>
		public PutUserDescriptor(Name username) : base(r=>r.Required("username", username)){}
		// values part of the url path
		Name IPutUserRequest.Username => Self.RouteValues.Get<Name>("username");

		// Request parameters

		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public PutUserDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}
	///<summary>descriptor for XpackSqlClearCursor <pre>Clear SQL cursor</pre></summary>
	public partial class ClearSqlCursorDescriptor  : RequestDescriptorBase<ClearSqlCursorDescriptor,ClearSqlCursorRequestParameters, IClearSqlCursorRequest>, IClearSqlCursorRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackSqlQuery <pre>Execute SQL</pre></summary>
	public partial class QuerySqlDescriptor  : RequestDescriptorBase<QuerySqlDescriptor,QuerySqlRequestParameters, IQuerySqlRequest>, IQuerySqlRequest
	{ 
		// values part of the url path

		// Request parameters

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public QuerySqlDescriptor Format(string format) => Qs("format", format);
	}
	///<summary>descriptor for XpackSqlTranslate <pre>Translate SQL into Elasticsearch queries</pre></summary>
	public partial class TranslateSqlDescriptor  : RequestDescriptorBase<TranslateSqlDescriptor,TranslateSqlRequestParameters, ITranslateSqlRequest>, ITranslateSqlRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackSslCertificates <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-ssl.html</pre></summary>
	public partial class GetCertificatesDescriptor  : RequestDescriptorBase<GetCertificatesDescriptor,GetCertificatesRequestParameters, IGetCertificatesRequest>, IGetCertificatesRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackWatcherAckWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-ack-watch.html</pre></summary>
	public partial class AcknowledgeWatchDescriptor  : RequestDescriptorBase<AcknowledgeWatchDescriptor,AcknowledgeWatchRequestParameters, IAcknowledgeWatchRequest>, IAcknowledgeWatchRequest
	{ 
		/// <summary>/_xpack/watcher/watch/{watch_id}/_ack</summary>
		///<param name="watch_id"> this parameter is required</param>
		public AcknowledgeWatchDescriptor(Id watch_id) : base(r=>r.Required("watch_id", watch_id)){}
		// values part of the url path
		Id IAcknowledgeWatchRequest.WatchId => Self.RouteValues.Get<Id>("watch_id");
		ActionIds IAcknowledgeWatchRequest.ActionId => Self.RouteValues.Get<ActionIds>("action_id");

		///<summary>A comma-separated list of the action ids to be acked</summary>
		public AcknowledgeWatchDescriptor ActionId(ActionIds actionId) => Assign(actionId, (a,v)=>a.RouteValues.Optional("action_id", v));

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public AcknowledgeWatchDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for XpackWatcherActivateWatch <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-activate-watch.html</pre></summary>
	public partial class ActivateWatchDescriptor  : RequestDescriptorBase<ActivateWatchDescriptor,ActivateWatchRequestParameters, IActivateWatchRequest>, IActivateWatchRequest
	{ 
		/// <summary>/_xpack/watcher/watch/{watch_id}/_activate</summary>
		///<param name="watch_id"> this parameter is required</param>
		public ActivateWatchDescriptor(Id watch_id) : base(r=>r.Required("watch_id", watch_id)){}
		// values part of the url path
		Id IActivateWatchRequest.WatchId => Self.RouteValues.Get<Id>("watch_id");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public ActivateWatchDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for XpackWatcherDeactivateWatch <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-deactivate-watch.html</pre></summary>
	public partial class DeactivateWatchDescriptor  : RequestDescriptorBase<DeactivateWatchDescriptor,DeactivateWatchRequestParameters, IDeactivateWatchRequest>, IDeactivateWatchRequest
	{ 
		/// <summary>/_xpack/watcher/watch/{watch_id}/_deactivate</summary>
		///<param name="watch_id"> this parameter is required</param>
		public DeactivateWatchDescriptor(Id watch_id) : base(r=>r.Required("watch_id", watch_id)){}
		// values part of the url path
		Id IDeactivateWatchRequest.WatchId => Self.RouteValues.Get<Id>("watch_id");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeactivateWatchDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for XpackWatcherDeleteWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-delete-watch.html</pre></summary>
	public partial class DeleteWatchDescriptor  : RequestDescriptorBase<DeleteWatchDescriptor,DeleteWatchRequestParameters, IDeleteWatchRequest>, IDeleteWatchRequest
	{ 
		/// <summary>/_xpack/watcher/watch/{id}</summary>
		///<param name="id"> this parameter is required</param>
		public DeleteWatchDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id IDeleteWatchRequest.Id => Self.RouteValues.Get<Id>("id");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeleteWatchDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
	///<summary>descriptor for XpackWatcherExecuteWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-execute-watch.html</pre></summary>
	public partial class ExecuteWatchDescriptor  : RequestDescriptorBase<ExecuteWatchDescriptor,ExecuteWatchRequestParameters, IExecuteWatchRequest>, IExecuteWatchRequest
	{ 
		/// <summary>/_xpack/watcher/watch/{id}/_execute</summary>
		public ExecuteWatchDescriptor() : base(){}
		// values part of the url path
		Id IExecuteWatchRequest.Id => Self.RouteValues.Get<Id>("id");

		///<summary>Watch ID</summary>
		public ExecuteWatchDescriptor Id(Id id) => Assign(id, (a,v)=>a.RouteValues.Optional("id", v));

		// Request parameters

		///<summary>indicates whether the watch should execute in debug mode</summary>
		public ExecuteWatchDescriptor Debug(bool? debug = true) => Qs("debug", debug);
	}
	///<summary>descriptor for XpackWatcherGetWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-get-watch.html</pre></summary>
	public partial class GetWatchDescriptor  : RequestDescriptorBase<GetWatchDescriptor,GetWatchRequestParameters, IGetWatchRequest>, IGetWatchRequest
	{ 
		/// <summary>/_xpack/watcher/watch/{id}</summary>
		///<param name="id"> this parameter is required</param>
		public GetWatchDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id IGetWatchRequest.Id => Self.RouteValues.Get<Id>("id");

		// Request parameters

	}
	///<summary>descriptor for XpackWatcherPutWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-put-watch.html</pre></summary>
	public partial class PutWatchDescriptor  : RequestDescriptorBase<PutWatchDescriptor,PutWatchRequestParameters, IPutWatchRequest>, IPutWatchRequest
	{ 
		/// <summary>/_xpack/watcher/watch/{id}</summary>
		///<param name="id"> this parameter is required</param>
		public PutWatchDescriptor(Id id) : base(r=>r.Required("id", id)){}
		// values part of the url path
		Id IPutWatchRequest.Id => Self.RouteValues.Get<Id>("id");

		// Request parameters

		///<summary>Explicit operation timeout for connection to master node</summary>
		public PutWatchDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Specify whether the watch is in/active by default</summary>
		public PutWatchDescriptor Active(bool? active = true) => Qs("active", active);
		///<summary>Explicit version number for concurrency control</summary>
		public PutWatchDescriptor Version(long? version) => Qs("version", version);
		///<summary>only update the watch if the last operation that has changed the watch has the specified sequence number</summary>
		public PutWatchDescriptor IfSeqNo(long? ifSeqNo) => Qs("if_seq_no", ifSeqNo);
		///<summary>only update the watch if the last operation that has changed the watch has the specified primary term</summary>
		public PutWatchDescriptor IfPrimaryTerm(long? ifPrimaryTerm) => Qs("if_primary_term", ifPrimaryTerm);
	}
	///<summary>descriptor for XpackWatcherRestart <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-restart.html</pre></summary>
	public partial class RestartWatcherDescriptor  : RequestDescriptorBase<RestartWatcherDescriptor,RestartWatcherRequestParameters, IRestartWatcherRequest>, IRestartWatcherRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackWatcherStart <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-start.html</pre></summary>
	public partial class StartWatcherDescriptor  : RequestDescriptorBase<StartWatcherDescriptor,StartWatcherRequestParameters, IStartWatcherRequest>, IStartWatcherRequest
	{ 
		// values part of the url path

		// Request parameters

	}
	///<summary>descriptor for XpackWatcherStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-stats.html</pre></summary>
	public partial class WatcherStatsDescriptor  : RequestDescriptorBase<WatcherStatsDescriptor,WatcherStatsRequestParameters, IWatcherStatsRequest>, IWatcherStatsRequest
	{ 
		/// <summary>/_xpack/watcher/stats</summary>
		public WatcherStatsDescriptor() : base(){}
		// values part of the url path
		Metrics IWatcherStatsRequest.WatcherStatsMetric => Self.RouteValues.Get<Metrics>("watcher_stats_metric");

		///<summary>Controls what additional stat metrics should be include in the response</summary>
		public WatcherStatsDescriptor WatcherStatsMetric(WatcherStatsMetric watcherStatsMetric) => Assign(watcherStatsMetric, (a,v)=>a.RouteValues.Optional("watcher_stats_metric", (Metrics)v));

		// Request parameters

		///<summary>Emits stack traces of currently running watches</summary>
		public WatcherStatsDescriptor EmitStacktraces(bool? emitStacktraces = true) => Qs("emit_stacktraces", emitStacktraces);
	}
	///<summary>descriptor for XpackWatcherStop <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-stop.html</pre></summary>
	public partial class StopWatcherDescriptor  : RequestDescriptorBase<StopWatcherDescriptor,StopWatcherRequestParameters, IStopWatcherRequest>, IStopWatcherRequest
	{ 
		// values part of the url path

		// Request parameters

	}}